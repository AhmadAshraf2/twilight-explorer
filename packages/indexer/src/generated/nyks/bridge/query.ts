// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: nyks/bridge/query.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { BtcDepositAddress } from "../volt/deposit";
import { BtcWithdrawRequestInternal } from "../volt/withdraw";
import { Params } from "./params";
import {
  MsgBootstrapFragment,
  MsgBroadcastTxRefund,
  MsgBroadcastTxSweep,
  MsgProposeRefundHash,
  MsgProposeSweepAddress,
  MsgRegisterReserveAddress,
  MsgSignRefund,
  MsgSignSweep,
  MsgUnsignedTxRefund,
  MsgUnsignedTxSweep,
} from "./tx";

export const protobufPackage = "twilightproject.nyks.bridge";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params?: Params | undefined;
}

export interface QueryRegisteredBtcDepositAddressesRequest {
}

export interface QueryRegisteredBtcDepositAddressesResponse {
  addresses: BtcDepositAddress[];
}

export interface QueryRegisteredReserveAddressesRequest {
}

export interface QueryRegisteredReserveAddressesResponse {
  addresses: MsgRegisterReserveAddress[];
}

export interface QueryRegisteredBtcDepositAddressRequest {
  depositAddress: string;
}

export interface QueryRegisteredBtcDepositAddressResponse {
  depositAddress: string;
  twilightDepositAddress: string;
}

export interface QueryRegisteredBtcDepositAddressByTwilightAddressRequest {
  twilightDepositAddress: string;
}

export interface QueryRegisteredBtcDepositAddressByTwilightAddressResponse {
  depositAddress: string;
  twilightDepositAddress: string;
}

/** this line is used by starport scaffolding # 3 */
export interface QueryRegisteredJudgeAddressByValidatorAddressRequest {
  validatorAddress: string;
}

export interface QueryRegisteredJudgeAddressByValidatorAddressResponse {
  judgeAddress: string;
  numOfSigners: string;
  threshold: string;
  signerApplicationFee: string;
  arbitraryData: string;
  validatorAddress: string;
}

export interface QueryRegisteredJudgesRequest {
}

export interface QueryRegisteredJudgesResponse {
  Judges: MsgBootstrapFragment[];
}

export interface QueryWithdrawBtcRequestAllRequest {
}

export interface QueryWithdrawBtcRequestAllResponse {
  withdrawRequest: BtcWithdrawRequestInternal[];
}

export interface QueryProposeRefundHashAllRequest {
}

export interface QueryProposeRefundHashAllResponse {
  proposeRefundHashMsg: MsgProposeRefundHash[];
}

/**
 * Sweep Queries
 * 1. ProposeSweepAddress
 */
export interface QueryProposeSweepAddressRequest {
  reserveId: string;
  roundId: string;
}

export interface QueryProposeSweepAddressResponse {
  proposeSweepAddressMsg?: MsgProposeSweepAddress | undefined;
}

export interface QueryProposeSweepAddressesAllRequest {
  limit: string;
}

export interface QueryProposeSweepAddressesAllResponse {
  proposeSweepAddressMsgs: MsgProposeSweepAddress[];
}

/** 2. UnsignedTxSweep */
export interface QueryUnsignedTxSweepRequest {
  reserveId: string;
  roundId: string;
}

export interface QueryUnsignedTxSweepResponse {
  unsignedTxSweepMsg?: MsgUnsignedTxSweep | undefined;
}

export interface QueryUnsignedTxSweepAllRequest {
  limit: string;
}

export interface QueryUnsignedTxSweepAllResponse {
  unsignedTxSweepMsgs: MsgUnsignedTxSweep[];
}

/** 3. UnsignedTxRefund */
export interface QueryUnsignedTxRefundRequest {
  reserveId: string;
  roundId: string;
}

export interface QueryUnsignedTxRefundResponse {
  unsignedTxRefundMsg?: MsgUnsignedTxRefund | undefined;
}

export interface QueryUnsignedTxRefundAllRequest {
  limit: string;
}

export interface QueryUnsignedTxRefundAllResponse {
  unsignedTxRefundMsgs: MsgUnsignedTxRefund[];
}

/** 4. SignRefund */
export interface QuerySignRefundRequest {
  reserveId: string;
  roundId: string;
}

export interface QuerySignRefundResponse {
  signRefundMsg: MsgSignRefund[];
}

export interface QuerySignRefundAllRequest {
}

export interface QuerySignRefundAllResponse {
  signRefundMsg: MsgSignRefund[];
}

/** 5. SignSweep */
export interface QuerySignSweepRequest {
  reserveId: string;
  roundId: string;
}

export interface QuerySignSweepResponse {
  signSweepMsg: MsgSignSweep[];
}

export interface QuerySignSweepAllRequest {
}

export interface QuerySignSweepAllResponse {
  signSweepMsg: MsgSignSweep[];
}

/** 6. BroadcastTxRefund */
export interface QueryBroadcastTxRefundRequest {
  reserveId: string;
  roundId: string;
}

export interface QueryBroadcastTxRefundResponse {
  broadcastRefundMsg?: MsgBroadcastTxRefund | undefined;
}

export interface QueryBroadcastTxRefundAllRequest {
}

export interface QueryBroadcastTxRefundAllResponse {
  BroadcastTxRefundMsg: MsgBroadcastTxRefund[];
}

/** 7. BroadcastTxSweep */
export interface QueryBroadcastTxSweepRequest {
  reserveId: string;
  roundId: string;
}

export interface QueryBroadcastTxSweepResponse {
  broadcastSweepMsg?: MsgBroadcastTxSweep | undefined;
}

export interface QueryBroadcastTxSweepAllRequest {
}

export interface QueryBroadcastTxSweepAllResponse {
  BroadcastTxSweepMsg: MsgBroadcastTxSweep[];
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest = {
  encode(_: QueryParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse = {
  encode(message: QueryParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryRegisteredBtcDepositAddressesRequest(): QueryRegisteredBtcDepositAddressesRequest {
  return {};
}

export const QueryRegisteredBtcDepositAddressesRequest = {
  encode(_: QueryRegisteredBtcDepositAddressesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredBtcDepositAddressesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredBtcDepositAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryRegisteredBtcDepositAddressesRequest {
    return {};
  },

  toJSON(_: QueryRegisteredBtcDepositAddressesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressesRequest>, I>>(
    base?: I,
  ): QueryRegisteredBtcDepositAddressesRequest {
    return QueryRegisteredBtcDepositAddressesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressesRequest>, I>>(
    _: I,
  ): QueryRegisteredBtcDepositAddressesRequest {
    const message = createBaseQueryRegisteredBtcDepositAddressesRequest();
    return message;
  },
};

function createBaseQueryRegisteredBtcDepositAddressesResponse(): QueryRegisteredBtcDepositAddressesResponse {
  return { addresses: [] };
}

export const QueryRegisteredBtcDepositAddressesResponse = {
  encode(message: QueryRegisteredBtcDepositAddressesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      BtcDepositAddress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredBtcDepositAddressesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredBtcDepositAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(BtcDepositAddress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredBtcDepositAddressesResponse {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => BtcDepositAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryRegisteredBtcDepositAddressesResponse): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => BtcDepositAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressesResponse>, I>>(
    base?: I,
  ): QueryRegisteredBtcDepositAddressesResponse {
    return QueryRegisteredBtcDepositAddressesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressesResponse>, I>>(
    object: I,
  ): QueryRegisteredBtcDepositAddressesResponse {
    const message = createBaseQueryRegisteredBtcDepositAddressesResponse();
    message.addresses = object.addresses?.map((e) => BtcDepositAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryRegisteredReserveAddressesRequest(): QueryRegisteredReserveAddressesRequest {
  return {};
}

export const QueryRegisteredReserveAddressesRequest = {
  encode(_: QueryRegisteredReserveAddressesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredReserveAddressesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredReserveAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryRegisteredReserveAddressesRequest {
    return {};
  },

  toJSON(_: QueryRegisteredReserveAddressesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredReserveAddressesRequest>, I>>(
    base?: I,
  ): QueryRegisteredReserveAddressesRequest {
    return QueryRegisteredReserveAddressesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredReserveAddressesRequest>, I>>(
    _: I,
  ): QueryRegisteredReserveAddressesRequest {
    const message = createBaseQueryRegisteredReserveAddressesRequest();
    return message;
  },
};

function createBaseQueryRegisteredReserveAddressesResponse(): QueryRegisteredReserveAddressesResponse {
  return { addresses: [] };
}

export const QueryRegisteredReserveAddressesResponse = {
  encode(message: QueryRegisteredReserveAddressesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      MsgRegisterReserveAddress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredReserveAddressesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredReserveAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(MsgRegisterReserveAddress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredReserveAddressesResponse {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => MsgRegisterReserveAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryRegisteredReserveAddressesResponse): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => MsgRegisterReserveAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredReserveAddressesResponse>, I>>(
    base?: I,
  ): QueryRegisteredReserveAddressesResponse {
    return QueryRegisteredReserveAddressesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredReserveAddressesResponse>, I>>(
    object: I,
  ): QueryRegisteredReserveAddressesResponse {
    const message = createBaseQueryRegisteredReserveAddressesResponse();
    message.addresses = object.addresses?.map((e) => MsgRegisterReserveAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryRegisteredBtcDepositAddressRequest(): QueryRegisteredBtcDepositAddressRequest {
  return { depositAddress: "" };
}

export const QueryRegisteredBtcDepositAddressRequest = {
  encode(message: QueryRegisteredBtcDepositAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.depositAddress !== "") {
      writer.uint32(10).string(message.depositAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredBtcDepositAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredBtcDepositAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredBtcDepositAddressRequest {
    return { depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "" };
  },

  toJSON(message: QueryRegisteredBtcDepositAddressRequest): unknown {
    const obj: any = {};
    if (message.depositAddress !== "") {
      obj.depositAddress = message.depositAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressRequest>, I>>(
    base?: I,
  ): QueryRegisteredBtcDepositAddressRequest {
    return QueryRegisteredBtcDepositAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressRequest>, I>>(
    object: I,
  ): QueryRegisteredBtcDepositAddressRequest {
    const message = createBaseQueryRegisteredBtcDepositAddressRequest();
    message.depositAddress = object.depositAddress ?? "";
    return message;
  },
};

function createBaseQueryRegisteredBtcDepositAddressResponse(): QueryRegisteredBtcDepositAddressResponse {
  return { depositAddress: "", twilightDepositAddress: "" };
}

export const QueryRegisteredBtcDepositAddressResponse = {
  encode(message: QueryRegisteredBtcDepositAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.depositAddress !== "") {
      writer.uint32(10).string(message.depositAddress);
    }
    if (message.twilightDepositAddress !== "") {
      writer.uint32(18).string(message.twilightDepositAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredBtcDepositAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredBtcDepositAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.twilightDepositAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredBtcDepositAddressResponse {
    return {
      depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
      twilightDepositAddress: isSet(object.twilightDepositAddress)
        ? globalThis.String(object.twilightDepositAddress)
        : "",
    };
  },

  toJSON(message: QueryRegisteredBtcDepositAddressResponse): unknown {
    const obj: any = {};
    if (message.depositAddress !== "") {
      obj.depositAddress = message.depositAddress;
    }
    if (message.twilightDepositAddress !== "") {
      obj.twilightDepositAddress = message.twilightDepositAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressResponse>, I>>(
    base?: I,
  ): QueryRegisteredBtcDepositAddressResponse {
    return QueryRegisteredBtcDepositAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressResponse>, I>>(
    object: I,
  ): QueryRegisteredBtcDepositAddressResponse {
    const message = createBaseQueryRegisteredBtcDepositAddressResponse();
    message.depositAddress = object.depositAddress ?? "";
    message.twilightDepositAddress = object.twilightDepositAddress ?? "";
    return message;
  },
};

function createBaseQueryRegisteredBtcDepositAddressByTwilightAddressRequest(): QueryRegisteredBtcDepositAddressByTwilightAddressRequest {
  return { twilightDepositAddress: "" };
}

export const QueryRegisteredBtcDepositAddressByTwilightAddressRequest = {
  encode(
    message: QueryRegisteredBtcDepositAddressByTwilightAddressRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.twilightDepositAddress !== "") {
      writer.uint32(10).string(message.twilightDepositAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredBtcDepositAddressByTwilightAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredBtcDepositAddressByTwilightAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.twilightDepositAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredBtcDepositAddressByTwilightAddressRequest {
    return {
      twilightDepositAddress: isSet(object.twilightDepositAddress)
        ? globalThis.String(object.twilightDepositAddress)
        : "",
    };
  },

  toJSON(message: QueryRegisteredBtcDepositAddressByTwilightAddressRequest): unknown {
    const obj: any = {};
    if (message.twilightDepositAddress !== "") {
      obj.twilightDepositAddress = message.twilightDepositAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressByTwilightAddressRequest>, I>>(
    base?: I,
  ): QueryRegisteredBtcDepositAddressByTwilightAddressRequest {
    return QueryRegisteredBtcDepositAddressByTwilightAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressByTwilightAddressRequest>, I>>(
    object: I,
  ): QueryRegisteredBtcDepositAddressByTwilightAddressRequest {
    const message = createBaseQueryRegisteredBtcDepositAddressByTwilightAddressRequest();
    message.twilightDepositAddress = object.twilightDepositAddress ?? "";
    return message;
  },
};

function createBaseQueryRegisteredBtcDepositAddressByTwilightAddressResponse(): QueryRegisteredBtcDepositAddressByTwilightAddressResponse {
  return { depositAddress: "", twilightDepositAddress: "" };
}

export const QueryRegisteredBtcDepositAddressByTwilightAddressResponse = {
  encode(
    message: QueryRegisteredBtcDepositAddressByTwilightAddressResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.depositAddress !== "") {
      writer.uint32(10).string(message.depositAddress);
    }
    if (message.twilightDepositAddress !== "") {
      writer.uint32(18).string(message.twilightDepositAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredBtcDepositAddressByTwilightAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredBtcDepositAddressByTwilightAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.depositAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.twilightDepositAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredBtcDepositAddressByTwilightAddressResponse {
    return {
      depositAddress: isSet(object.depositAddress) ? globalThis.String(object.depositAddress) : "",
      twilightDepositAddress: isSet(object.twilightDepositAddress)
        ? globalThis.String(object.twilightDepositAddress)
        : "",
    };
  },

  toJSON(message: QueryRegisteredBtcDepositAddressByTwilightAddressResponse): unknown {
    const obj: any = {};
    if (message.depositAddress !== "") {
      obj.depositAddress = message.depositAddress;
    }
    if (message.twilightDepositAddress !== "") {
      obj.twilightDepositAddress = message.twilightDepositAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressByTwilightAddressResponse>, I>>(
    base?: I,
  ): QueryRegisteredBtcDepositAddressByTwilightAddressResponse {
    return QueryRegisteredBtcDepositAddressByTwilightAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredBtcDepositAddressByTwilightAddressResponse>, I>>(
    object: I,
  ): QueryRegisteredBtcDepositAddressByTwilightAddressResponse {
    const message = createBaseQueryRegisteredBtcDepositAddressByTwilightAddressResponse();
    message.depositAddress = object.depositAddress ?? "";
    message.twilightDepositAddress = object.twilightDepositAddress ?? "";
    return message;
  },
};

function createBaseQueryRegisteredJudgeAddressByValidatorAddressRequest(): QueryRegisteredJudgeAddressByValidatorAddressRequest {
  return { validatorAddress: "" };
}

export const QueryRegisteredJudgeAddressByValidatorAddressRequest = {
  encode(
    message: QueryRegisteredJudgeAddressByValidatorAddressRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredJudgeAddressByValidatorAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredJudgeAddressByValidatorAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredJudgeAddressByValidatorAddressRequest {
    return { validatorAddress: isSet(object.validatorAddress) ? globalThis.String(object.validatorAddress) : "" };
  },

  toJSON(message: QueryRegisteredJudgeAddressByValidatorAddressRequest): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredJudgeAddressByValidatorAddressRequest>, I>>(
    base?: I,
  ): QueryRegisteredJudgeAddressByValidatorAddressRequest {
    return QueryRegisteredJudgeAddressByValidatorAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredJudgeAddressByValidatorAddressRequest>, I>>(
    object: I,
  ): QueryRegisteredJudgeAddressByValidatorAddressRequest {
    const message = createBaseQueryRegisteredJudgeAddressByValidatorAddressRequest();
    message.validatorAddress = object.validatorAddress ?? "";
    return message;
  },
};

function createBaseQueryRegisteredJudgeAddressByValidatorAddressResponse(): QueryRegisteredJudgeAddressByValidatorAddressResponse {
  return {
    judgeAddress: "",
    numOfSigners: "0",
    threshold: "0",
    signerApplicationFee: "0",
    arbitraryData: "",
    validatorAddress: "",
  };
}

export const QueryRegisteredJudgeAddressByValidatorAddressResponse = {
  encode(
    message: QueryRegisteredJudgeAddressByValidatorAddressResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.judgeAddress !== "") {
      writer.uint32(10).string(message.judgeAddress);
    }
    if (message.numOfSigners !== "0") {
      writer.uint32(16).uint64(message.numOfSigners);
    }
    if (message.threshold !== "0") {
      writer.uint32(24).uint64(message.threshold);
    }
    if (message.signerApplicationFee !== "0") {
      writer.uint32(32).uint64(message.signerApplicationFee);
    }
    if (message.arbitraryData !== "") {
      writer.uint32(42).string(message.arbitraryData);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(50).string(message.validatorAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredJudgeAddressByValidatorAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredJudgeAddressByValidatorAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numOfSigners = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.threshold = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.signerApplicationFee = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.arbitraryData = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredJudgeAddressByValidatorAddressResponse {
    return {
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
      numOfSigners: isSet(object.numOfSigners) ? globalThis.String(object.numOfSigners) : "0",
      threshold: isSet(object.threshold) ? globalThis.String(object.threshold) : "0",
      signerApplicationFee: isSet(object.signerApplicationFee) ? globalThis.String(object.signerApplicationFee) : "0",
      arbitraryData: isSet(object.arbitraryData) ? globalThis.String(object.arbitraryData) : "",
      validatorAddress: isSet(object.validatorAddress) ? globalThis.String(object.validatorAddress) : "",
    };
  },

  toJSON(message: QueryRegisteredJudgeAddressByValidatorAddressResponse): unknown {
    const obj: any = {};
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    if (message.numOfSigners !== "0") {
      obj.numOfSigners = message.numOfSigners;
    }
    if (message.threshold !== "0") {
      obj.threshold = message.threshold;
    }
    if (message.signerApplicationFee !== "0") {
      obj.signerApplicationFee = message.signerApplicationFee;
    }
    if (message.arbitraryData !== "") {
      obj.arbitraryData = message.arbitraryData;
    }
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredJudgeAddressByValidatorAddressResponse>, I>>(
    base?: I,
  ): QueryRegisteredJudgeAddressByValidatorAddressResponse {
    return QueryRegisteredJudgeAddressByValidatorAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredJudgeAddressByValidatorAddressResponse>, I>>(
    object: I,
  ): QueryRegisteredJudgeAddressByValidatorAddressResponse {
    const message = createBaseQueryRegisteredJudgeAddressByValidatorAddressResponse();
    message.judgeAddress = object.judgeAddress ?? "";
    message.numOfSigners = object.numOfSigners ?? "0";
    message.threshold = object.threshold ?? "0";
    message.signerApplicationFee = object.signerApplicationFee ?? "0";
    message.arbitraryData = object.arbitraryData ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    return message;
  },
};

function createBaseQueryRegisteredJudgesRequest(): QueryRegisteredJudgesRequest {
  return {};
}

export const QueryRegisteredJudgesRequest = {
  encode(_: QueryRegisteredJudgesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredJudgesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredJudgesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryRegisteredJudgesRequest {
    return {};
  },

  toJSON(_: QueryRegisteredJudgesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredJudgesRequest>, I>>(base?: I): QueryRegisteredJudgesRequest {
    return QueryRegisteredJudgesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredJudgesRequest>, I>>(_: I): QueryRegisteredJudgesRequest {
    const message = createBaseQueryRegisteredJudgesRequest();
    return message;
  },
};

function createBaseQueryRegisteredJudgesResponse(): QueryRegisteredJudgesResponse {
  return { Judges: [] };
}

export const QueryRegisteredJudgesResponse = {
  encode(message: QueryRegisteredJudgesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Judges) {
      MsgBootstrapFragment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRegisteredJudgesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRegisteredJudgesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Judges.push(MsgBootstrapFragment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRegisteredJudgesResponse {
    return {
      Judges: globalThis.Array.isArray(object?.Judges)
        ? object.Judges.map((e: any) => MsgBootstrapFragment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryRegisteredJudgesResponse): unknown {
    const obj: any = {};
    if (message.Judges?.length) {
      obj.Judges = message.Judges.map((e) => MsgBootstrapFragment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRegisteredJudgesResponse>, I>>(base?: I): QueryRegisteredJudgesResponse {
    return QueryRegisteredJudgesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRegisteredJudgesResponse>, I>>(
    object: I,
  ): QueryRegisteredJudgesResponse {
    const message = createBaseQueryRegisteredJudgesResponse();
    message.Judges = object.Judges?.map((e) => MsgBootstrapFragment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryWithdrawBtcRequestAllRequest(): QueryWithdrawBtcRequestAllRequest {
  return {};
}

export const QueryWithdrawBtcRequestAllRequest = {
  encode(_: QueryWithdrawBtcRequestAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryWithdrawBtcRequestAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryWithdrawBtcRequestAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryWithdrawBtcRequestAllRequest {
    return {};
  },

  toJSON(_: QueryWithdrawBtcRequestAllRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryWithdrawBtcRequestAllRequest>, I>>(
    base?: I,
  ): QueryWithdrawBtcRequestAllRequest {
    return QueryWithdrawBtcRequestAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryWithdrawBtcRequestAllRequest>, I>>(
    _: I,
  ): QueryWithdrawBtcRequestAllRequest {
    const message = createBaseQueryWithdrawBtcRequestAllRequest();
    return message;
  },
};

function createBaseQueryWithdrawBtcRequestAllResponse(): QueryWithdrawBtcRequestAllResponse {
  return { withdrawRequest: [] };
}

export const QueryWithdrawBtcRequestAllResponse = {
  encode(message: QueryWithdrawBtcRequestAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.withdrawRequest) {
      BtcWithdrawRequestInternal.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryWithdrawBtcRequestAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryWithdrawBtcRequestAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.withdrawRequest.push(BtcWithdrawRequestInternal.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryWithdrawBtcRequestAllResponse {
    return {
      withdrawRequest: globalThis.Array.isArray(object?.withdrawRequest)
        ? object.withdrawRequest.map((e: any) => BtcWithdrawRequestInternal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryWithdrawBtcRequestAllResponse): unknown {
    const obj: any = {};
    if (message.withdrawRequest?.length) {
      obj.withdrawRequest = message.withdrawRequest.map((e) => BtcWithdrawRequestInternal.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryWithdrawBtcRequestAllResponse>, I>>(
    base?: I,
  ): QueryWithdrawBtcRequestAllResponse {
    return QueryWithdrawBtcRequestAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryWithdrawBtcRequestAllResponse>, I>>(
    object: I,
  ): QueryWithdrawBtcRequestAllResponse {
    const message = createBaseQueryWithdrawBtcRequestAllResponse();
    message.withdrawRequest = object.withdrawRequest?.map((e) => BtcWithdrawRequestInternal.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryProposeRefundHashAllRequest(): QueryProposeRefundHashAllRequest {
  return {};
}

export const QueryProposeRefundHashAllRequest = {
  encode(_: QueryProposeRefundHashAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryProposeRefundHashAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposeRefundHashAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryProposeRefundHashAllRequest {
    return {};
  },

  toJSON(_: QueryProposeRefundHashAllRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryProposeRefundHashAllRequest>, I>>(
    base?: I,
  ): QueryProposeRefundHashAllRequest {
    return QueryProposeRefundHashAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryProposeRefundHashAllRequest>, I>>(
    _: I,
  ): QueryProposeRefundHashAllRequest {
    const message = createBaseQueryProposeRefundHashAllRequest();
    return message;
  },
};

function createBaseQueryProposeRefundHashAllResponse(): QueryProposeRefundHashAllResponse {
  return { proposeRefundHashMsg: [] };
}

export const QueryProposeRefundHashAllResponse = {
  encode(message: QueryProposeRefundHashAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.proposeRefundHashMsg) {
      MsgProposeRefundHash.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryProposeRefundHashAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposeRefundHashAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proposeRefundHashMsg.push(MsgProposeRefundHash.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposeRefundHashAllResponse {
    return {
      proposeRefundHashMsg: globalThis.Array.isArray(object?.proposeRefundHashMsg)
        ? object.proposeRefundHashMsg.map((e: any) => MsgProposeRefundHash.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryProposeRefundHashAllResponse): unknown {
    const obj: any = {};
    if (message.proposeRefundHashMsg?.length) {
      obj.proposeRefundHashMsg = message.proposeRefundHashMsg.map((e) => MsgProposeRefundHash.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryProposeRefundHashAllResponse>, I>>(
    base?: I,
  ): QueryProposeRefundHashAllResponse {
    return QueryProposeRefundHashAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryProposeRefundHashAllResponse>, I>>(
    object: I,
  ): QueryProposeRefundHashAllResponse {
    const message = createBaseQueryProposeRefundHashAllResponse();
    message.proposeRefundHashMsg = object.proposeRefundHashMsg?.map((e) => MsgProposeRefundHash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryProposeSweepAddressRequest(): QueryProposeSweepAddressRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QueryProposeSweepAddressRequest = {
  encode(message: QueryProposeSweepAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryProposeSweepAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposeSweepAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposeSweepAddressRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QueryProposeSweepAddressRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryProposeSweepAddressRequest>, I>>(base?: I): QueryProposeSweepAddressRequest {
    return QueryProposeSweepAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryProposeSweepAddressRequest>, I>>(
    object: I,
  ): QueryProposeSweepAddressRequest {
    const message = createBaseQueryProposeSweepAddressRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQueryProposeSweepAddressResponse(): QueryProposeSweepAddressResponse {
  return { proposeSweepAddressMsg: undefined };
}

export const QueryProposeSweepAddressResponse = {
  encode(message: QueryProposeSweepAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.proposeSweepAddressMsg !== undefined) {
      MsgProposeSweepAddress.encode(message.proposeSweepAddressMsg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryProposeSweepAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposeSweepAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proposeSweepAddressMsg = MsgProposeSweepAddress.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposeSweepAddressResponse {
    return {
      proposeSweepAddressMsg: isSet(object.proposeSweepAddressMsg)
        ? MsgProposeSweepAddress.fromJSON(object.proposeSweepAddressMsg)
        : undefined,
    };
  },

  toJSON(message: QueryProposeSweepAddressResponse): unknown {
    const obj: any = {};
    if (message.proposeSweepAddressMsg !== undefined) {
      obj.proposeSweepAddressMsg = MsgProposeSweepAddress.toJSON(message.proposeSweepAddressMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryProposeSweepAddressResponse>, I>>(
    base?: I,
  ): QueryProposeSweepAddressResponse {
    return QueryProposeSweepAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryProposeSweepAddressResponse>, I>>(
    object: I,
  ): QueryProposeSweepAddressResponse {
    const message = createBaseQueryProposeSweepAddressResponse();
    message.proposeSweepAddressMsg =
      (object.proposeSweepAddressMsg !== undefined && object.proposeSweepAddressMsg !== null)
        ? MsgProposeSweepAddress.fromPartial(object.proposeSweepAddressMsg)
        : undefined;
    return message;
  },
};

function createBaseQueryProposeSweepAddressesAllRequest(): QueryProposeSweepAddressesAllRequest {
  return { limit: "0" };
}

export const QueryProposeSweepAddressesAllRequest = {
  encode(message: QueryProposeSweepAddressesAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== "0") {
      writer.uint32(8).uint64(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryProposeSweepAddressesAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposeSweepAddressesAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposeSweepAddressesAllRequest {
    return { limit: isSet(object.limit) ? globalThis.String(object.limit) : "0" };
  },

  toJSON(message: QueryProposeSweepAddressesAllRequest): unknown {
    const obj: any = {};
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryProposeSweepAddressesAllRequest>, I>>(
    base?: I,
  ): QueryProposeSweepAddressesAllRequest {
    return QueryProposeSweepAddressesAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryProposeSweepAddressesAllRequest>, I>>(
    object: I,
  ): QueryProposeSweepAddressesAllRequest {
    const message = createBaseQueryProposeSweepAddressesAllRequest();
    message.limit = object.limit ?? "0";
    return message;
  },
};

function createBaseQueryProposeSweepAddressesAllResponse(): QueryProposeSweepAddressesAllResponse {
  return { proposeSweepAddressMsgs: [] };
}

export const QueryProposeSweepAddressesAllResponse = {
  encode(message: QueryProposeSweepAddressesAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.proposeSweepAddressMsgs) {
      MsgProposeSweepAddress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryProposeSweepAddressesAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProposeSweepAddressesAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proposeSweepAddressMsgs.push(MsgProposeSweepAddress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryProposeSweepAddressesAllResponse {
    return {
      proposeSweepAddressMsgs: globalThis.Array.isArray(object?.proposeSweepAddressMsgs)
        ? object.proposeSweepAddressMsgs.map((e: any) => MsgProposeSweepAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryProposeSweepAddressesAllResponse): unknown {
    const obj: any = {};
    if (message.proposeSweepAddressMsgs?.length) {
      obj.proposeSweepAddressMsgs = message.proposeSweepAddressMsgs.map((e) => MsgProposeSweepAddress.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryProposeSweepAddressesAllResponse>, I>>(
    base?: I,
  ): QueryProposeSweepAddressesAllResponse {
    return QueryProposeSweepAddressesAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryProposeSweepAddressesAllResponse>, I>>(
    object: I,
  ): QueryProposeSweepAddressesAllResponse {
    const message = createBaseQueryProposeSweepAddressesAllResponse();
    message.proposeSweepAddressMsgs =
      object.proposeSweepAddressMsgs?.map((e) => MsgProposeSweepAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryUnsignedTxSweepRequest(): QueryUnsignedTxSweepRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QueryUnsignedTxSweepRequest = {
  encode(message: QueryUnsignedTxSweepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnsignedTxSweepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnsignedTxSweepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnsignedTxSweepRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QueryUnsignedTxSweepRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnsignedTxSweepRequest>, I>>(base?: I): QueryUnsignedTxSweepRequest {
    return QueryUnsignedTxSweepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnsignedTxSweepRequest>, I>>(object: I): QueryUnsignedTxSweepRequest {
    const message = createBaseQueryUnsignedTxSweepRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQueryUnsignedTxSweepResponse(): QueryUnsignedTxSweepResponse {
  return { unsignedTxSweepMsg: undefined };
}

export const QueryUnsignedTxSweepResponse = {
  encode(message: QueryUnsignedTxSweepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unsignedTxSweepMsg !== undefined) {
      MsgUnsignedTxSweep.encode(message.unsignedTxSweepMsg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnsignedTxSweepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnsignedTxSweepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unsignedTxSweepMsg = MsgUnsignedTxSweep.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnsignedTxSweepResponse {
    return {
      unsignedTxSweepMsg: isSet(object.unsignedTxSweepMsg)
        ? MsgUnsignedTxSweep.fromJSON(object.unsignedTxSweepMsg)
        : undefined,
    };
  },

  toJSON(message: QueryUnsignedTxSweepResponse): unknown {
    const obj: any = {};
    if (message.unsignedTxSweepMsg !== undefined) {
      obj.unsignedTxSweepMsg = MsgUnsignedTxSweep.toJSON(message.unsignedTxSweepMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnsignedTxSweepResponse>, I>>(base?: I): QueryUnsignedTxSweepResponse {
    return QueryUnsignedTxSweepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnsignedTxSweepResponse>, I>>(object: I): QueryUnsignedTxSweepResponse {
    const message = createBaseQueryUnsignedTxSweepResponse();
    message.unsignedTxSweepMsg = (object.unsignedTxSweepMsg !== undefined && object.unsignedTxSweepMsg !== null)
      ? MsgUnsignedTxSweep.fromPartial(object.unsignedTxSweepMsg)
      : undefined;
    return message;
  },
};

function createBaseQueryUnsignedTxSweepAllRequest(): QueryUnsignedTxSweepAllRequest {
  return { limit: "0" };
}

export const QueryUnsignedTxSweepAllRequest = {
  encode(message: QueryUnsignedTxSweepAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== "0") {
      writer.uint32(8).uint64(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnsignedTxSweepAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnsignedTxSweepAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnsignedTxSweepAllRequest {
    return { limit: isSet(object.limit) ? globalThis.String(object.limit) : "0" };
  },

  toJSON(message: QueryUnsignedTxSweepAllRequest): unknown {
    const obj: any = {};
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnsignedTxSweepAllRequest>, I>>(base?: I): QueryUnsignedTxSweepAllRequest {
    return QueryUnsignedTxSweepAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnsignedTxSweepAllRequest>, I>>(
    object: I,
  ): QueryUnsignedTxSweepAllRequest {
    const message = createBaseQueryUnsignedTxSweepAllRequest();
    message.limit = object.limit ?? "0";
    return message;
  },
};

function createBaseQueryUnsignedTxSweepAllResponse(): QueryUnsignedTxSweepAllResponse {
  return { unsignedTxSweepMsgs: [] };
}

export const QueryUnsignedTxSweepAllResponse = {
  encode(message: QueryUnsignedTxSweepAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.unsignedTxSweepMsgs) {
      MsgUnsignedTxSweep.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnsignedTxSweepAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnsignedTxSweepAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unsignedTxSweepMsgs.push(MsgUnsignedTxSweep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnsignedTxSweepAllResponse {
    return {
      unsignedTxSweepMsgs: globalThis.Array.isArray(object?.unsignedTxSweepMsgs)
        ? object.unsignedTxSweepMsgs.map((e: any) => MsgUnsignedTxSweep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryUnsignedTxSweepAllResponse): unknown {
    const obj: any = {};
    if (message.unsignedTxSweepMsgs?.length) {
      obj.unsignedTxSweepMsgs = message.unsignedTxSweepMsgs.map((e) => MsgUnsignedTxSweep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnsignedTxSweepAllResponse>, I>>(base?: I): QueryUnsignedTxSweepAllResponse {
    return QueryUnsignedTxSweepAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnsignedTxSweepAllResponse>, I>>(
    object: I,
  ): QueryUnsignedTxSweepAllResponse {
    const message = createBaseQueryUnsignedTxSweepAllResponse();
    message.unsignedTxSweepMsgs = object.unsignedTxSweepMsgs?.map((e) => MsgUnsignedTxSweep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryUnsignedTxRefundRequest(): QueryUnsignedTxRefundRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QueryUnsignedTxRefundRequest = {
  encode(message: QueryUnsignedTxRefundRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnsignedTxRefundRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnsignedTxRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnsignedTxRefundRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QueryUnsignedTxRefundRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnsignedTxRefundRequest>, I>>(base?: I): QueryUnsignedTxRefundRequest {
    return QueryUnsignedTxRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnsignedTxRefundRequest>, I>>(object: I): QueryUnsignedTxRefundRequest {
    const message = createBaseQueryUnsignedTxRefundRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQueryUnsignedTxRefundResponse(): QueryUnsignedTxRefundResponse {
  return { unsignedTxRefundMsg: undefined };
}

export const QueryUnsignedTxRefundResponse = {
  encode(message: QueryUnsignedTxRefundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unsignedTxRefundMsg !== undefined) {
      MsgUnsignedTxRefund.encode(message.unsignedTxRefundMsg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnsignedTxRefundResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnsignedTxRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unsignedTxRefundMsg = MsgUnsignedTxRefund.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnsignedTxRefundResponse {
    return {
      unsignedTxRefundMsg: isSet(object.unsignedTxRefundMsg)
        ? MsgUnsignedTxRefund.fromJSON(object.unsignedTxRefundMsg)
        : undefined,
    };
  },

  toJSON(message: QueryUnsignedTxRefundResponse): unknown {
    const obj: any = {};
    if (message.unsignedTxRefundMsg !== undefined) {
      obj.unsignedTxRefundMsg = MsgUnsignedTxRefund.toJSON(message.unsignedTxRefundMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnsignedTxRefundResponse>, I>>(base?: I): QueryUnsignedTxRefundResponse {
    return QueryUnsignedTxRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnsignedTxRefundResponse>, I>>(
    object: I,
  ): QueryUnsignedTxRefundResponse {
    const message = createBaseQueryUnsignedTxRefundResponse();
    message.unsignedTxRefundMsg = (object.unsignedTxRefundMsg !== undefined && object.unsignedTxRefundMsg !== null)
      ? MsgUnsignedTxRefund.fromPartial(object.unsignedTxRefundMsg)
      : undefined;
    return message;
  },
};

function createBaseQueryUnsignedTxRefundAllRequest(): QueryUnsignedTxRefundAllRequest {
  return { limit: "0" };
}

export const QueryUnsignedTxRefundAllRequest = {
  encode(message: QueryUnsignedTxRefundAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== "0") {
      writer.uint32(8).uint64(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnsignedTxRefundAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnsignedTxRefundAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnsignedTxRefundAllRequest {
    return { limit: isSet(object.limit) ? globalThis.String(object.limit) : "0" };
  },

  toJSON(message: QueryUnsignedTxRefundAllRequest): unknown {
    const obj: any = {};
    if (message.limit !== "0") {
      obj.limit = message.limit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnsignedTxRefundAllRequest>, I>>(base?: I): QueryUnsignedTxRefundAllRequest {
    return QueryUnsignedTxRefundAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnsignedTxRefundAllRequest>, I>>(
    object: I,
  ): QueryUnsignedTxRefundAllRequest {
    const message = createBaseQueryUnsignedTxRefundAllRequest();
    message.limit = object.limit ?? "0";
    return message;
  },
};

function createBaseQueryUnsignedTxRefundAllResponse(): QueryUnsignedTxRefundAllResponse {
  return { unsignedTxRefundMsgs: [] };
}

export const QueryUnsignedTxRefundAllResponse = {
  encode(message: QueryUnsignedTxRefundAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.unsignedTxRefundMsgs) {
      MsgUnsignedTxRefund.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryUnsignedTxRefundAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnsignedTxRefundAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unsignedTxRefundMsgs.push(MsgUnsignedTxRefund.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnsignedTxRefundAllResponse {
    return {
      unsignedTxRefundMsgs: globalThis.Array.isArray(object?.unsignedTxRefundMsgs)
        ? object.unsignedTxRefundMsgs.map((e: any) => MsgUnsignedTxRefund.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryUnsignedTxRefundAllResponse): unknown {
    const obj: any = {};
    if (message.unsignedTxRefundMsgs?.length) {
      obj.unsignedTxRefundMsgs = message.unsignedTxRefundMsgs.map((e) => MsgUnsignedTxRefund.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnsignedTxRefundAllResponse>, I>>(
    base?: I,
  ): QueryUnsignedTxRefundAllResponse {
    return QueryUnsignedTxRefundAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnsignedTxRefundAllResponse>, I>>(
    object: I,
  ): QueryUnsignedTxRefundAllResponse {
    const message = createBaseQueryUnsignedTxRefundAllResponse();
    message.unsignedTxRefundMsgs = object.unsignedTxRefundMsgs?.map((e) => MsgUnsignedTxRefund.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySignRefundRequest(): QuerySignRefundRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QuerySignRefundRequest = {
  encode(message: QuerySignRefundRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignRefundRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignRefundRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QuerySignRefundRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignRefundRequest>, I>>(base?: I): QuerySignRefundRequest {
    return QuerySignRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignRefundRequest>, I>>(object: I): QuerySignRefundRequest {
    const message = createBaseQuerySignRefundRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQuerySignRefundResponse(): QuerySignRefundResponse {
  return { signRefundMsg: [] };
}

export const QuerySignRefundResponse = {
  encode(message: QuerySignRefundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.signRefundMsg) {
      MsgSignRefund.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignRefundResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signRefundMsg.push(MsgSignRefund.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignRefundResponse {
    return {
      signRefundMsg: globalThis.Array.isArray(object?.signRefundMsg)
        ? object.signRefundMsg.map((e: any) => MsgSignRefund.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySignRefundResponse): unknown {
    const obj: any = {};
    if (message.signRefundMsg?.length) {
      obj.signRefundMsg = message.signRefundMsg.map((e) => MsgSignRefund.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignRefundResponse>, I>>(base?: I): QuerySignRefundResponse {
    return QuerySignRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignRefundResponse>, I>>(object: I): QuerySignRefundResponse {
    const message = createBaseQuerySignRefundResponse();
    message.signRefundMsg = object.signRefundMsg?.map((e) => MsgSignRefund.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySignRefundAllRequest(): QuerySignRefundAllRequest {
  return {};
}

export const QuerySignRefundAllRequest = {
  encode(_: QuerySignRefundAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignRefundAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignRefundAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QuerySignRefundAllRequest {
    return {};
  },

  toJSON(_: QuerySignRefundAllRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignRefundAllRequest>, I>>(base?: I): QuerySignRefundAllRequest {
    return QuerySignRefundAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignRefundAllRequest>, I>>(_: I): QuerySignRefundAllRequest {
    const message = createBaseQuerySignRefundAllRequest();
    return message;
  },
};

function createBaseQuerySignRefundAllResponse(): QuerySignRefundAllResponse {
  return { signRefundMsg: [] };
}

export const QuerySignRefundAllResponse = {
  encode(message: QuerySignRefundAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.signRefundMsg) {
      MsgSignRefund.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignRefundAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignRefundAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signRefundMsg.push(MsgSignRefund.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignRefundAllResponse {
    return {
      signRefundMsg: globalThis.Array.isArray(object?.signRefundMsg)
        ? object.signRefundMsg.map((e: any) => MsgSignRefund.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySignRefundAllResponse): unknown {
    const obj: any = {};
    if (message.signRefundMsg?.length) {
      obj.signRefundMsg = message.signRefundMsg.map((e) => MsgSignRefund.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignRefundAllResponse>, I>>(base?: I): QuerySignRefundAllResponse {
    return QuerySignRefundAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignRefundAllResponse>, I>>(object: I): QuerySignRefundAllResponse {
    const message = createBaseQuerySignRefundAllResponse();
    message.signRefundMsg = object.signRefundMsg?.map((e) => MsgSignRefund.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySignSweepRequest(): QuerySignSweepRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QuerySignSweepRequest = {
  encode(message: QuerySignSweepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignSweepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignSweepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignSweepRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QuerySignSweepRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignSweepRequest>, I>>(base?: I): QuerySignSweepRequest {
    return QuerySignSweepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignSweepRequest>, I>>(object: I): QuerySignSweepRequest {
    const message = createBaseQuerySignSweepRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQuerySignSweepResponse(): QuerySignSweepResponse {
  return { signSweepMsg: [] };
}

export const QuerySignSweepResponse = {
  encode(message: QuerySignSweepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.signSweepMsg) {
      MsgSignSweep.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignSweepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignSweepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signSweepMsg.push(MsgSignSweep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignSweepResponse {
    return {
      signSweepMsg: globalThis.Array.isArray(object?.signSweepMsg)
        ? object.signSweepMsg.map((e: any) => MsgSignSweep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySignSweepResponse): unknown {
    const obj: any = {};
    if (message.signSweepMsg?.length) {
      obj.signSweepMsg = message.signSweepMsg.map((e) => MsgSignSweep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignSweepResponse>, I>>(base?: I): QuerySignSweepResponse {
    return QuerySignSweepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignSweepResponse>, I>>(object: I): QuerySignSweepResponse {
    const message = createBaseQuerySignSweepResponse();
    message.signSweepMsg = object.signSweepMsg?.map((e) => MsgSignSweep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySignSweepAllRequest(): QuerySignSweepAllRequest {
  return {};
}

export const QuerySignSweepAllRequest = {
  encode(_: QuerySignSweepAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignSweepAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignSweepAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QuerySignSweepAllRequest {
    return {};
  },

  toJSON(_: QuerySignSweepAllRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignSweepAllRequest>, I>>(base?: I): QuerySignSweepAllRequest {
    return QuerySignSweepAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignSweepAllRequest>, I>>(_: I): QuerySignSweepAllRequest {
    const message = createBaseQuerySignSweepAllRequest();
    return message;
  },
};

function createBaseQuerySignSweepAllResponse(): QuerySignSweepAllResponse {
  return { signSweepMsg: [] };
}

export const QuerySignSweepAllResponse = {
  encode(message: QuerySignSweepAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.signSweepMsg) {
      MsgSignSweep.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignSweepAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignSweepAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signSweepMsg.push(MsgSignSweep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignSweepAllResponse {
    return {
      signSweepMsg: globalThis.Array.isArray(object?.signSweepMsg)
        ? object.signSweepMsg.map((e: any) => MsgSignSweep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySignSweepAllResponse): unknown {
    const obj: any = {};
    if (message.signSweepMsg?.length) {
      obj.signSweepMsg = message.signSweepMsg.map((e) => MsgSignSweep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignSweepAllResponse>, I>>(base?: I): QuerySignSweepAllResponse {
    return QuerySignSweepAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignSweepAllResponse>, I>>(object: I): QuerySignSweepAllResponse {
    const message = createBaseQuerySignSweepAllResponse();
    message.signSweepMsg = object.signSweepMsg?.map((e) => MsgSignSweep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryBroadcastTxRefundRequest(): QueryBroadcastTxRefundRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QueryBroadcastTxRefundRequest = {
  encode(message: QueryBroadcastTxRefundRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBroadcastTxRefundRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBroadcastTxRefundRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBroadcastTxRefundRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QueryBroadcastTxRefundRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBroadcastTxRefundRequest>, I>>(base?: I): QueryBroadcastTxRefundRequest {
    return QueryBroadcastTxRefundRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBroadcastTxRefundRequest>, I>>(
    object: I,
  ): QueryBroadcastTxRefundRequest {
    const message = createBaseQueryBroadcastTxRefundRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQueryBroadcastTxRefundResponse(): QueryBroadcastTxRefundResponse {
  return { broadcastRefundMsg: undefined };
}

export const QueryBroadcastTxRefundResponse = {
  encode(message: QueryBroadcastTxRefundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.broadcastRefundMsg !== undefined) {
      MsgBroadcastTxRefund.encode(message.broadcastRefundMsg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBroadcastTxRefundResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBroadcastTxRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.broadcastRefundMsg = MsgBroadcastTxRefund.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBroadcastTxRefundResponse {
    return {
      broadcastRefundMsg: isSet(object.broadcastRefundMsg)
        ? MsgBroadcastTxRefund.fromJSON(object.broadcastRefundMsg)
        : undefined,
    };
  },

  toJSON(message: QueryBroadcastTxRefundResponse): unknown {
    const obj: any = {};
    if (message.broadcastRefundMsg !== undefined) {
      obj.broadcastRefundMsg = MsgBroadcastTxRefund.toJSON(message.broadcastRefundMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBroadcastTxRefundResponse>, I>>(base?: I): QueryBroadcastTxRefundResponse {
    return QueryBroadcastTxRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBroadcastTxRefundResponse>, I>>(
    object: I,
  ): QueryBroadcastTxRefundResponse {
    const message = createBaseQueryBroadcastTxRefundResponse();
    message.broadcastRefundMsg = (object.broadcastRefundMsg !== undefined && object.broadcastRefundMsg !== null)
      ? MsgBroadcastTxRefund.fromPartial(object.broadcastRefundMsg)
      : undefined;
    return message;
  },
};

function createBaseQueryBroadcastTxRefundAllRequest(): QueryBroadcastTxRefundAllRequest {
  return {};
}

export const QueryBroadcastTxRefundAllRequest = {
  encode(_: QueryBroadcastTxRefundAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBroadcastTxRefundAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBroadcastTxRefundAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryBroadcastTxRefundAllRequest {
    return {};
  },

  toJSON(_: QueryBroadcastTxRefundAllRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBroadcastTxRefundAllRequest>, I>>(
    base?: I,
  ): QueryBroadcastTxRefundAllRequest {
    return QueryBroadcastTxRefundAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBroadcastTxRefundAllRequest>, I>>(
    _: I,
  ): QueryBroadcastTxRefundAllRequest {
    const message = createBaseQueryBroadcastTxRefundAllRequest();
    return message;
  },
};

function createBaseQueryBroadcastTxRefundAllResponse(): QueryBroadcastTxRefundAllResponse {
  return { BroadcastTxRefundMsg: [] };
}

export const QueryBroadcastTxRefundAllResponse = {
  encode(message: QueryBroadcastTxRefundAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.BroadcastTxRefundMsg) {
      MsgBroadcastTxRefund.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBroadcastTxRefundAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBroadcastTxRefundAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.BroadcastTxRefundMsg.push(MsgBroadcastTxRefund.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBroadcastTxRefundAllResponse {
    return {
      BroadcastTxRefundMsg: globalThis.Array.isArray(object?.BroadcastTxRefundMsg)
        ? object.BroadcastTxRefundMsg.map((e: any) => MsgBroadcastTxRefund.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBroadcastTxRefundAllResponse): unknown {
    const obj: any = {};
    if (message.BroadcastTxRefundMsg?.length) {
      obj.BroadcastTxRefundMsg = message.BroadcastTxRefundMsg.map((e) => MsgBroadcastTxRefund.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBroadcastTxRefundAllResponse>, I>>(
    base?: I,
  ): QueryBroadcastTxRefundAllResponse {
    return QueryBroadcastTxRefundAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBroadcastTxRefundAllResponse>, I>>(
    object: I,
  ): QueryBroadcastTxRefundAllResponse {
    const message = createBaseQueryBroadcastTxRefundAllResponse();
    message.BroadcastTxRefundMsg = object.BroadcastTxRefundMsg?.map((e) => MsgBroadcastTxRefund.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryBroadcastTxSweepRequest(): QueryBroadcastTxSweepRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QueryBroadcastTxSweepRequest = {
  encode(message: QueryBroadcastTxSweepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBroadcastTxSweepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBroadcastTxSweepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBroadcastTxSweepRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QueryBroadcastTxSweepRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBroadcastTxSweepRequest>, I>>(base?: I): QueryBroadcastTxSweepRequest {
    return QueryBroadcastTxSweepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBroadcastTxSweepRequest>, I>>(object: I): QueryBroadcastTxSweepRequest {
    const message = createBaseQueryBroadcastTxSweepRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQueryBroadcastTxSweepResponse(): QueryBroadcastTxSweepResponse {
  return { broadcastSweepMsg: undefined };
}

export const QueryBroadcastTxSweepResponse = {
  encode(message: QueryBroadcastTxSweepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.broadcastSweepMsg !== undefined) {
      MsgBroadcastTxSweep.encode(message.broadcastSweepMsg, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBroadcastTxSweepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBroadcastTxSweepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.broadcastSweepMsg = MsgBroadcastTxSweep.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBroadcastTxSweepResponse {
    return {
      broadcastSweepMsg: isSet(object.broadcastSweepMsg)
        ? MsgBroadcastTxSweep.fromJSON(object.broadcastSweepMsg)
        : undefined,
    };
  },

  toJSON(message: QueryBroadcastTxSweepResponse): unknown {
    const obj: any = {};
    if (message.broadcastSweepMsg !== undefined) {
      obj.broadcastSweepMsg = MsgBroadcastTxSweep.toJSON(message.broadcastSweepMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBroadcastTxSweepResponse>, I>>(base?: I): QueryBroadcastTxSweepResponse {
    return QueryBroadcastTxSweepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBroadcastTxSweepResponse>, I>>(
    object: I,
  ): QueryBroadcastTxSweepResponse {
    const message = createBaseQueryBroadcastTxSweepResponse();
    message.broadcastSweepMsg = (object.broadcastSweepMsg !== undefined && object.broadcastSweepMsg !== null)
      ? MsgBroadcastTxSweep.fromPartial(object.broadcastSweepMsg)
      : undefined;
    return message;
  },
};

function createBaseQueryBroadcastTxSweepAllRequest(): QueryBroadcastTxSweepAllRequest {
  return {};
}

export const QueryBroadcastTxSweepAllRequest = {
  encode(_: QueryBroadcastTxSweepAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBroadcastTxSweepAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBroadcastTxSweepAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryBroadcastTxSweepAllRequest {
    return {};
  },

  toJSON(_: QueryBroadcastTxSweepAllRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBroadcastTxSweepAllRequest>, I>>(base?: I): QueryBroadcastTxSweepAllRequest {
    return QueryBroadcastTxSweepAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBroadcastTxSweepAllRequest>, I>>(_: I): QueryBroadcastTxSweepAllRequest {
    const message = createBaseQueryBroadcastTxSweepAllRequest();
    return message;
  },
};

function createBaseQueryBroadcastTxSweepAllResponse(): QueryBroadcastTxSweepAllResponse {
  return { BroadcastTxSweepMsg: [] };
}

export const QueryBroadcastTxSweepAllResponse = {
  encode(message: QueryBroadcastTxSweepAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.BroadcastTxSweepMsg) {
      MsgBroadcastTxSweep.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBroadcastTxSweepAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBroadcastTxSweepAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.BroadcastTxSweepMsg.push(MsgBroadcastTxSweep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBroadcastTxSweepAllResponse {
    return {
      BroadcastTxSweepMsg: globalThis.Array.isArray(object?.BroadcastTxSweepMsg)
        ? object.BroadcastTxSweepMsg.map((e: any) => MsgBroadcastTxSweep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBroadcastTxSweepAllResponse): unknown {
    const obj: any = {};
    if (message.BroadcastTxSweepMsg?.length) {
      obj.BroadcastTxSweepMsg = message.BroadcastTxSweepMsg.map((e) => MsgBroadcastTxSweep.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBroadcastTxSweepAllResponse>, I>>(
    base?: I,
  ): QueryBroadcastTxSweepAllResponse {
    return QueryBroadcastTxSweepAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBroadcastTxSweepAllResponse>, I>>(
    object: I,
  ): QueryBroadcastTxSweepAllResponse {
    const message = createBaseQueryBroadcastTxSweepAllResponse();
    message.BroadcastTxSweepMsg = object.BroadcastTxSweepMsg?.map((e) => MsgBroadcastTxSweep.fromPartial(e)) || [];
    return message;
  },
};

/** Query defines the gRPC querier service. */
export type QueryService = typeof QueryService;
export const QueryService = {
  /** Parameters queries the parameters of the module. */
  params: {
    path: "/twilightproject.nyks.bridge.Query/Params",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryParamsRequest) => Buffer.from(QueryParamsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryParamsRequest.decode(value),
    responseSerialize: (value: QueryParamsResponse) => Buffer.from(QueryParamsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryParamsResponse.decode(value),
  },
  /** Queries a list of RegisteredBtcDepositAddresses items. */
  registeredBtcDepositAddresses: {
    path: "/twilightproject.nyks.bridge.Query/RegisteredBtcDepositAddresses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRegisteredBtcDepositAddressesRequest) =>
      Buffer.from(QueryRegisteredBtcDepositAddressesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRegisteredBtcDepositAddressesRequest.decode(value),
    responseSerialize: (value: QueryRegisteredBtcDepositAddressesResponse) =>
      Buffer.from(QueryRegisteredBtcDepositAddressesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryRegisteredBtcDepositAddressesResponse.decode(value),
  },
  /** Queries a list of RegisteredReserveAddresses items. */
  registeredReserveAddresses: {
    path: "/twilightproject.nyks.bridge.Query/RegisteredReserveAddresses",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRegisteredReserveAddressesRequest) =>
      Buffer.from(QueryRegisteredReserveAddressesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRegisteredReserveAddressesRequest.decode(value),
    responseSerialize: (value: QueryRegisteredReserveAddressesResponse) =>
      Buffer.from(QueryRegisteredReserveAddressesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryRegisteredReserveAddressesResponse.decode(value),
  },
  /** Queries a list of RegisteredBtcDepositAddress items. */
  registeredBtcDepositAddress: {
    path: "/twilightproject.nyks.bridge.Query/RegisteredBtcDepositAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRegisteredBtcDepositAddressRequest) =>
      Buffer.from(QueryRegisteredBtcDepositAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRegisteredBtcDepositAddressRequest.decode(value),
    responseSerialize: (value: QueryRegisteredBtcDepositAddressResponse) =>
      Buffer.from(QueryRegisteredBtcDepositAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryRegisteredBtcDepositAddressResponse.decode(value),
  },
  /** Queries a list of RegisteredBtcDepositAddressByTwilightAddress items. */
  registeredBtcDepositAddressByTwilightAddress: {
    path: "/twilightproject.nyks.bridge.Query/RegisteredBtcDepositAddressByTwilightAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRegisteredBtcDepositAddressByTwilightAddressRequest) =>
      Buffer.from(QueryRegisteredBtcDepositAddressByTwilightAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRegisteredBtcDepositAddressByTwilightAddressRequest.decode(value),
    responseSerialize: (value: QueryRegisteredBtcDepositAddressByTwilightAddressResponse) =>
      Buffer.from(QueryRegisteredBtcDepositAddressByTwilightAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryRegisteredBtcDepositAddressByTwilightAddressResponse.decode(value),
  },
  /** Queries a list of RegisteredJudgeAddressByValidatorAddress items. */
  registeredJudgeAddressByValidatorAddress: {
    path: "/twilightproject.nyks.bridge.Query/RegisteredJudgeAddressByValidatorAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRegisteredJudgeAddressByValidatorAddressRequest) =>
      Buffer.from(QueryRegisteredJudgeAddressByValidatorAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRegisteredJudgeAddressByValidatorAddressRequest.decode(value),
    responseSerialize: (value: QueryRegisteredJudgeAddressByValidatorAddressResponse) =>
      Buffer.from(QueryRegisteredJudgeAddressByValidatorAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryRegisteredJudgeAddressByValidatorAddressResponse.decode(value),
  },
  /** Queries a list of RegisteredJudges items. */
  registeredJudges: {
    path: "/twilightproject.nyks.bridge.Query/RegisteredJudges",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRegisteredJudgesRequest) =>
      Buffer.from(QueryRegisteredJudgesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRegisteredJudgesRequest.decode(value),
    responseSerialize: (value: QueryRegisteredJudgesResponse) =>
      Buffer.from(QueryRegisteredJudgesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryRegisteredJudgesResponse.decode(value),
  },
  /** Queries a list of WithdrawBtcRequestAll items. */
  withdrawBtcRequestAll: {
    path: "/twilightproject.nyks.bridge.Query/WithdrawBtcRequestAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryWithdrawBtcRequestAllRequest) =>
      Buffer.from(QueryWithdrawBtcRequestAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryWithdrawBtcRequestAllRequest.decode(value),
    responseSerialize: (value: QueryWithdrawBtcRequestAllResponse) =>
      Buffer.from(QueryWithdrawBtcRequestAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryWithdrawBtcRequestAllResponse.decode(value),
  },
  /** Queries a list of SignRefundAll items. */
  signRefundAll: {
    path: "/twilightproject.nyks.bridge.Query/SignRefundAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QuerySignRefundAllRequest) =>
      Buffer.from(QuerySignRefundAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QuerySignRefundAllRequest.decode(value),
    responseSerialize: (value: QuerySignRefundAllResponse) =>
      Buffer.from(QuerySignRefundAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QuerySignRefundAllResponse.decode(value),
  },
  /** Queries a list of SignSweepAll items. */
  signSweepAll: {
    path: "/twilightproject.nyks.bridge.Query/SignSweepAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QuerySignSweepAllRequest) => Buffer.from(QuerySignSweepAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QuerySignSweepAllRequest.decode(value),
    responseSerialize: (value: QuerySignSweepAllResponse) =>
      Buffer.from(QuerySignSweepAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QuerySignSweepAllResponse.decode(value),
  },
  /** Queries a list of BroadcastTxSweepAll items. */
  broadcastTxSweepAll: {
    path: "/twilightproject.nyks.bridge.Query/BroadcastTxSweepAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryBroadcastTxSweepAllRequest) =>
      Buffer.from(QueryBroadcastTxSweepAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryBroadcastTxSweepAllRequest.decode(value),
    responseSerialize: (value: QueryBroadcastTxSweepAllResponse) =>
      Buffer.from(QueryBroadcastTxSweepAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryBroadcastTxSweepAllResponse.decode(value),
  },
  /** Queries a list of ProposeRefundHashAll items. */
  proposeRefundHashAll: {
    path: "/twilightproject.nyks.bridge.Query/ProposeRefundHashAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryProposeRefundHashAllRequest) =>
      Buffer.from(QueryProposeRefundHashAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryProposeRefundHashAllRequest.decode(value),
    responseSerialize: (value: QueryProposeRefundHashAllResponse) =>
      Buffer.from(QueryProposeRefundHashAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryProposeRefundHashAllResponse.decode(value),
  },
  /** Queries a list of UnsignedTxSweep items. */
  unsignedTxSweep: {
    path: "/twilightproject.nyks.bridge.Query/UnsignedTxSweep",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryUnsignedTxSweepRequest) =>
      Buffer.from(QueryUnsignedTxSweepRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryUnsignedTxSweepRequest.decode(value),
    responseSerialize: (value: QueryUnsignedTxSweepResponse) =>
      Buffer.from(QueryUnsignedTxSweepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryUnsignedTxSweepResponse.decode(value),
  },
  /** Queries a list of UnsignedTxRefund items. */
  unsignedTxRefund: {
    path: "/twilightproject.nyks.bridge.Query/UnsignedTxRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryUnsignedTxRefundRequest) =>
      Buffer.from(QueryUnsignedTxRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryUnsignedTxRefundRequest.decode(value),
    responseSerialize: (value: QueryUnsignedTxRefundResponse) =>
      Buffer.from(QueryUnsignedTxRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryUnsignedTxRefundResponse.decode(value),
  },
  /** Queries a list of UnsignedTxSweepAll items. */
  unsignedTxSweepAll: {
    path: "/twilightproject.nyks.bridge.Query/UnsignedTxSweepAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryUnsignedTxSweepAllRequest) =>
      Buffer.from(QueryUnsignedTxSweepAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryUnsignedTxSweepAllRequest.decode(value),
    responseSerialize: (value: QueryUnsignedTxSweepAllResponse) =>
      Buffer.from(QueryUnsignedTxSweepAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryUnsignedTxSweepAllResponse.decode(value),
  },
  /** Queries a list of UnsignedTxRefundAll items. */
  unsignedTxRefundAll: {
    path: "/twilightproject.nyks.bridge.Query/UnsignedTxRefundAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryUnsignedTxRefundAllRequest) =>
      Buffer.from(QueryUnsignedTxRefundAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryUnsignedTxRefundAllRequest.decode(value),
    responseSerialize: (value: QueryUnsignedTxRefundAllResponse) =>
      Buffer.from(QueryUnsignedTxRefundAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryUnsignedTxRefundAllResponse.decode(value),
  },
  /** Queries a list of BroadcastTxRefundAll items. */
  broadcastTxRefundAll: {
    path: "/twilightproject.nyks.bridge.Query/BroadcastTxRefundAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryBroadcastTxRefundAllRequest) =>
      Buffer.from(QueryBroadcastTxRefundAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryBroadcastTxRefundAllRequest.decode(value),
    responseSerialize: (value: QueryBroadcastTxRefundAllResponse) =>
      Buffer.from(QueryBroadcastTxRefundAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryBroadcastTxRefundAllResponse.decode(value),
  },
  /** Queries a list of ProposeSweepAddress items. */
  proposeSweepAddress: {
    path: "/twilightproject.nyks.bridge.Query/ProposeSweepAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryProposeSweepAddressRequest) =>
      Buffer.from(QueryProposeSweepAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryProposeSweepAddressRequest.decode(value),
    responseSerialize: (value: QueryProposeSweepAddressResponse) =>
      Buffer.from(QueryProposeSweepAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryProposeSweepAddressResponse.decode(value),
  },
  /** Queries a list of ProposeSweepAddressesAll items. */
  proposeSweepAddressesAll: {
    path: "/twilightproject.nyks.bridge.Query/ProposeSweepAddressesAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryProposeSweepAddressesAllRequest) =>
      Buffer.from(QueryProposeSweepAddressesAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryProposeSweepAddressesAllRequest.decode(value),
    responseSerialize: (value: QueryProposeSweepAddressesAllResponse) =>
      Buffer.from(QueryProposeSweepAddressesAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryProposeSweepAddressesAllResponse.decode(value),
  },
  /** Queries a list of SignRefund items. */
  signRefund: {
    path: "/twilightproject.nyks.bridge.Query/SignRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QuerySignRefundRequest) => Buffer.from(QuerySignRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QuerySignRefundRequest.decode(value),
    responseSerialize: (value: QuerySignRefundResponse) => Buffer.from(QuerySignRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QuerySignRefundResponse.decode(value),
  },
  /** Queries a list of SignSweep items. */
  signSweep: {
    path: "/twilightproject.nyks.bridge.Query/SignSweep",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QuerySignSweepRequest) => Buffer.from(QuerySignSweepRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QuerySignSweepRequest.decode(value),
    responseSerialize: (value: QuerySignSweepResponse) => Buffer.from(QuerySignSweepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QuerySignSweepResponse.decode(value),
  },
  /** Queries a list of BroadcastTxRefund items. */
  broadcastTxRefund: {
    path: "/twilightproject.nyks.bridge.Query/BroadcastTxRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryBroadcastTxRefundRequest) =>
      Buffer.from(QueryBroadcastTxRefundRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryBroadcastTxRefundRequest.decode(value),
    responseSerialize: (value: QueryBroadcastTxRefundResponse) =>
      Buffer.from(QueryBroadcastTxRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryBroadcastTxRefundResponse.decode(value),
  },
  /** Queries a list of BroadcastTxSweep items. */
  broadcastTxSweep: {
    path: "/twilightproject.nyks.bridge.Query/BroadcastTxSweep",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryBroadcastTxSweepRequest) =>
      Buffer.from(QueryBroadcastTxSweepRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryBroadcastTxSweepRequest.decode(value),
    responseSerialize: (value: QueryBroadcastTxSweepResponse) =>
      Buffer.from(QueryBroadcastTxSweepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryBroadcastTxSweepResponse.decode(value),
  },
} as const;

export interface QueryServer extends UntypedServiceImplementation {
  /** Parameters queries the parameters of the module. */
  params: handleUnaryCall<QueryParamsRequest, QueryParamsResponse>;
  /** Queries a list of RegisteredBtcDepositAddresses items. */
  registeredBtcDepositAddresses: handleUnaryCall<
    QueryRegisteredBtcDepositAddressesRequest,
    QueryRegisteredBtcDepositAddressesResponse
  >;
  /** Queries a list of RegisteredReserveAddresses items. */
  registeredReserveAddresses: handleUnaryCall<
    QueryRegisteredReserveAddressesRequest,
    QueryRegisteredReserveAddressesResponse
  >;
  /** Queries a list of RegisteredBtcDepositAddress items. */
  registeredBtcDepositAddress: handleUnaryCall<
    QueryRegisteredBtcDepositAddressRequest,
    QueryRegisteredBtcDepositAddressResponse
  >;
  /** Queries a list of RegisteredBtcDepositAddressByTwilightAddress items. */
  registeredBtcDepositAddressByTwilightAddress: handleUnaryCall<
    QueryRegisteredBtcDepositAddressByTwilightAddressRequest,
    QueryRegisteredBtcDepositAddressByTwilightAddressResponse
  >;
  /** Queries a list of RegisteredJudgeAddressByValidatorAddress items. */
  registeredJudgeAddressByValidatorAddress: handleUnaryCall<
    QueryRegisteredJudgeAddressByValidatorAddressRequest,
    QueryRegisteredJudgeAddressByValidatorAddressResponse
  >;
  /** Queries a list of RegisteredJudges items. */
  registeredJudges: handleUnaryCall<QueryRegisteredJudgesRequest, QueryRegisteredJudgesResponse>;
  /** Queries a list of WithdrawBtcRequestAll items. */
  withdrawBtcRequestAll: handleUnaryCall<QueryWithdrawBtcRequestAllRequest, QueryWithdrawBtcRequestAllResponse>;
  /** Queries a list of SignRefundAll items. */
  signRefundAll: handleUnaryCall<QuerySignRefundAllRequest, QuerySignRefundAllResponse>;
  /** Queries a list of SignSweepAll items. */
  signSweepAll: handleUnaryCall<QuerySignSweepAllRequest, QuerySignSweepAllResponse>;
  /** Queries a list of BroadcastTxSweepAll items. */
  broadcastTxSweepAll: handleUnaryCall<QueryBroadcastTxSweepAllRequest, QueryBroadcastTxSweepAllResponse>;
  /** Queries a list of ProposeRefundHashAll items. */
  proposeRefundHashAll: handleUnaryCall<QueryProposeRefundHashAllRequest, QueryProposeRefundHashAllResponse>;
  /** Queries a list of UnsignedTxSweep items. */
  unsignedTxSweep: handleUnaryCall<QueryUnsignedTxSweepRequest, QueryUnsignedTxSweepResponse>;
  /** Queries a list of UnsignedTxRefund items. */
  unsignedTxRefund: handleUnaryCall<QueryUnsignedTxRefundRequest, QueryUnsignedTxRefundResponse>;
  /** Queries a list of UnsignedTxSweepAll items. */
  unsignedTxSweepAll: handleUnaryCall<QueryUnsignedTxSweepAllRequest, QueryUnsignedTxSweepAllResponse>;
  /** Queries a list of UnsignedTxRefundAll items. */
  unsignedTxRefundAll: handleUnaryCall<QueryUnsignedTxRefundAllRequest, QueryUnsignedTxRefundAllResponse>;
  /** Queries a list of BroadcastTxRefundAll items. */
  broadcastTxRefundAll: handleUnaryCall<QueryBroadcastTxRefundAllRequest, QueryBroadcastTxRefundAllResponse>;
  /** Queries a list of ProposeSweepAddress items. */
  proposeSweepAddress: handleUnaryCall<QueryProposeSweepAddressRequest, QueryProposeSweepAddressResponse>;
  /** Queries a list of ProposeSweepAddressesAll items. */
  proposeSweepAddressesAll: handleUnaryCall<
    QueryProposeSweepAddressesAllRequest,
    QueryProposeSweepAddressesAllResponse
  >;
  /** Queries a list of SignRefund items. */
  signRefund: handleUnaryCall<QuerySignRefundRequest, QuerySignRefundResponse>;
  /** Queries a list of SignSweep items. */
  signSweep: handleUnaryCall<QuerySignSweepRequest, QuerySignSweepResponse>;
  /** Queries a list of BroadcastTxRefund items. */
  broadcastTxRefund: handleUnaryCall<QueryBroadcastTxRefundRequest, QueryBroadcastTxRefundResponse>;
  /** Queries a list of BroadcastTxSweep items. */
  broadcastTxSweep: handleUnaryCall<QueryBroadcastTxSweepRequest, QueryBroadcastTxSweepResponse>;
}

export interface QueryClient extends Client {
  /** Parameters queries the parameters of the module. */
  params(
    request: QueryParamsRequest,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  params(
    request: QueryParamsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  params(
    request: QueryParamsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of RegisteredBtcDepositAddresses items. */
  registeredBtcDepositAddresses(
    request: QueryRegisteredBtcDepositAddressesRequest,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressesResponse) => void,
  ): ClientUnaryCall;
  registeredBtcDepositAddresses(
    request: QueryRegisteredBtcDepositAddressesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressesResponse) => void,
  ): ClientUnaryCall;
  registeredBtcDepositAddresses(
    request: QueryRegisteredBtcDepositAddressesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressesResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of RegisteredReserveAddresses items. */
  registeredReserveAddresses(
    request: QueryRegisteredReserveAddressesRequest,
    callback: (error: ServiceError | null, response: QueryRegisteredReserveAddressesResponse) => void,
  ): ClientUnaryCall;
  registeredReserveAddresses(
    request: QueryRegisteredReserveAddressesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRegisteredReserveAddressesResponse) => void,
  ): ClientUnaryCall;
  registeredReserveAddresses(
    request: QueryRegisteredReserveAddressesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRegisteredReserveAddressesResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of RegisteredBtcDepositAddress items. */
  registeredBtcDepositAddress(
    request: QueryRegisteredBtcDepositAddressRequest,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressResponse) => void,
  ): ClientUnaryCall;
  registeredBtcDepositAddress(
    request: QueryRegisteredBtcDepositAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressResponse) => void,
  ): ClientUnaryCall;
  registeredBtcDepositAddress(
    request: QueryRegisteredBtcDepositAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of RegisteredBtcDepositAddressByTwilightAddress items. */
  registeredBtcDepositAddressByTwilightAddress(
    request: QueryRegisteredBtcDepositAddressByTwilightAddressRequest,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressByTwilightAddressResponse) => void,
  ): ClientUnaryCall;
  registeredBtcDepositAddressByTwilightAddress(
    request: QueryRegisteredBtcDepositAddressByTwilightAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressByTwilightAddressResponse) => void,
  ): ClientUnaryCall;
  registeredBtcDepositAddressByTwilightAddress(
    request: QueryRegisteredBtcDepositAddressByTwilightAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRegisteredBtcDepositAddressByTwilightAddressResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of RegisteredJudgeAddressByValidatorAddress items. */
  registeredJudgeAddressByValidatorAddress(
    request: QueryRegisteredJudgeAddressByValidatorAddressRequest,
    callback: (error: ServiceError | null, response: QueryRegisteredJudgeAddressByValidatorAddressResponse) => void,
  ): ClientUnaryCall;
  registeredJudgeAddressByValidatorAddress(
    request: QueryRegisteredJudgeAddressByValidatorAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRegisteredJudgeAddressByValidatorAddressResponse) => void,
  ): ClientUnaryCall;
  registeredJudgeAddressByValidatorAddress(
    request: QueryRegisteredJudgeAddressByValidatorAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRegisteredJudgeAddressByValidatorAddressResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of RegisteredJudges items. */
  registeredJudges(
    request: QueryRegisteredJudgesRequest,
    callback: (error: ServiceError | null, response: QueryRegisteredJudgesResponse) => void,
  ): ClientUnaryCall;
  registeredJudges(
    request: QueryRegisteredJudgesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRegisteredJudgesResponse) => void,
  ): ClientUnaryCall;
  registeredJudges(
    request: QueryRegisteredJudgesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRegisteredJudgesResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of WithdrawBtcRequestAll items. */
  withdrawBtcRequestAll(
    request: QueryWithdrawBtcRequestAllRequest,
    callback: (error: ServiceError | null, response: QueryWithdrawBtcRequestAllResponse) => void,
  ): ClientUnaryCall;
  withdrawBtcRequestAll(
    request: QueryWithdrawBtcRequestAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryWithdrawBtcRequestAllResponse) => void,
  ): ClientUnaryCall;
  withdrawBtcRequestAll(
    request: QueryWithdrawBtcRequestAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryWithdrawBtcRequestAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of SignRefundAll items. */
  signRefundAll(
    request: QuerySignRefundAllRequest,
    callback: (error: ServiceError | null, response: QuerySignRefundAllResponse) => void,
  ): ClientUnaryCall;
  signRefundAll(
    request: QuerySignRefundAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QuerySignRefundAllResponse) => void,
  ): ClientUnaryCall;
  signRefundAll(
    request: QuerySignRefundAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QuerySignRefundAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of SignSweepAll items. */
  signSweepAll(
    request: QuerySignSweepAllRequest,
    callback: (error: ServiceError | null, response: QuerySignSweepAllResponse) => void,
  ): ClientUnaryCall;
  signSweepAll(
    request: QuerySignSweepAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QuerySignSweepAllResponse) => void,
  ): ClientUnaryCall;
  signSweepAll(
    request: QuerySignSweepAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QuerySignSweepAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of BroadcastTxSweepAll items. */
  broadcastTxSweepAll(
    request: QueryBroadcastTxSweepAllRequest,
    callback: (error: ServiceError | null, response: QueryBroadcastTxSweepAllResponse) => void,
  ): ClientUnaryCall;
  broadcastTxSweepAll(
    request: QueryBroadcastTxSweepAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryBroadcastTxSweepAllResponse) => void,
  ): ClientUnaryCall;
  broadcastTxSweepAll(
    request: QueryBroadcastTxSweepAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryBroadcastTxSweepAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of ProposeRefundHashAll items. */
  proposeRefundHashAll(
    request: QueryProposeRefundHashAllRequest,
    callback: (error: ServiceError | null, response: QueryProposeRefundHashAllResponse) => void,
  ): ClientUnaryCall;
  proposeRefundHashAll(
    request: QueryProposeRefundHashAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryProposeRefundHashAllResponse) => void,
  ): ClientUnaryCall;
  proposeRefundHashAll(
    request: QueryProposeRefundHashAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryProposeRefundHashAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of UnsignedTxSweep items. */
  unsignedTxSweep(
    request: QueryUnsignedTxSweepRequest,
    callback: (error: ServiceError | null, response: QueryUnsignedTxSweepResponse) => void,
  ): ClientUnaryCall;
  unsignedTxSweep(
    request: QueryUnsignedTxSweepRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryUnsignedTxSweepResponse) => void,
  ): ClientUnaryCall;
  unsignedTxSweep(
    request: QueryUnsignedTxSweepRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryUnsignedTxSweepResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of UnsignedTxRefund items. */
  unsignedTxRefund(
    request: QueryUnsignedTxRefundRequest,
    callback: (error: ServiceError | null, response: QueryUnsignedTxRefundResponse) => void,
  ): ClientUnaryCall;
  unsignedTxRefund(
    request: QueryUnsignedTxRefundRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryUnsignedTxRefundResponse) => void,
  ): ClientUnaryCall;
  unsignedTxRefund(
    request: QueryUnsignedTxRefundRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryUnsignedTxRefundResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of UnsignedTxSweepAll items. */
  unsignedTxSweepAll(
    request: QueryUnsignedTxSweepAllRequest,
    callback: (error: ServiceError | null, response: QueryUnsignedTxSweepAllResponse) => void,
  ): ClientUnaryCall;
  unsignedTxSweepAll(
    request: QueryUnsignedTxSweepAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryUnsignedTxSweepAllResponse) => void,
  ): ClientUnaryCall;
  unsignedTxSweepAll(
    request: QueryUnsignedTxSweepAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryUnsignedTxSweepAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of UnsignedTxRefundAll items. */
  unsignedTxRefundAll(
    request: QueryUnsignedTxRefundAllRequest,
    callback: (error: ServiceError | null, response: QueryUnsignedTxRefundAllResponse) => void,
  ): ClientUnaryCall;
  unsignedTxRefundAll(
    request: QueryUnsignedTxRefundAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryUnsignedTxRefundAllResponse) => void,
  ): ClientUnaryCall;
  unsignedTxRefundAll(
    request: QueryUnsignedTxRefundAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryUnsignedTxRefundAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of BroadcastTxRefundAll items. */
  broadcastTxRefundAll(
    request: QueryBroadcastTxRefundAllRequest,
    callback: (error: ServiceError | null, response: QueryBroadcastTxRefundAllResponse) => void,
  ): ClientUnaryCall;
  broadcastTxRefundAll(
    request: QueryBroadcastTxRefundAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryBroadcastTxRefundAllResponse) => void,
  ): ClientUnaryCall;
  broadcastTxRefundAll(
    request: QueryBroadcastTxRefundAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryBroadcastTxRefundAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of ProposeSweepAddress items. */
  proposeSweepAddress(
    request: QueryProposeSweepAddressRequest,
    callback: (error: ServiceError | null, response: QueryProposeSweepAddressResponse) => void,
  ): ClientUnaryCall;
  proposeSweepAddress(
    request: QueryProposeSweepAddressRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryProposeSweepAddressResponse) => void,
  ): ClientUnaryCall;
  proposeSweepAddress(
    request: QueryProposeSweepAddressRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryProposeSweepAddressResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of ProposeSweepAddressesAll items. */
  proposeSweepAddressesAll(
    request: QueryProposeSweepAddressesAllRequest,
    callback: (error: ServiceError | null, response: QueryProposeSweepAddressesAllResponse) => void,
  ): ClientUnaryCall;
  proposeSweepAddressesAll(
    request: QueryProposeSweepAddressesAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryProposeSweepAddressesAllResponse) => void,
  ): ClientUnaryCall;
  proposeSweepAddressesAll(
    request: QueryProposeSweepAddressesAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryProposeSweepAddressesAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of SignRefund items. */
  signRefund(
    request: QuerySignRefundRequest,
    callback: (error: ServiceError | null, response: QuerySignRefundResponse) => void,
  ): ClientUnaryCall;
  signRefund(
    request: QuerySignRefundRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QuerySignRefundResponse) => void,
  ): ClientUnaryCall;
  signRefund(
    request: QuerySignRefundRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QuerySignRefundResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of SignSweep items. */
  signSweep(
    request: QuerySignSweepRequest,
    callback: (error: ServiceError | null, response: QuerySignSweepResponse) => void,
  ): ClientUnaryCall;
  signSweep(
    request: QuerySignSweepRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QuerySignSweepResponse) => void,
  ): ClientUnaryCall;
  signSweep(
    request: QuerySignSweepRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QuerySignSweepResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of BroadcastTxRefund items. */
  broadcastTxRefund(
    request: QueryBroadcastTxRefundRequest,
    callback: (error: ServiceError | null, response: QueryBroadcastTxRefundResponse) => void,
  ): ClientUnaryCall;
  broadcastTxRefund(
    request: QueryBroadcastTxRefundRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryBroadcastTxRefundResponse) => void,
  ): ClientUnaryCall;
  broadcastTxRefund(
    request: QueryBroadcastTxRefundRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryBroadcastTxRefundResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of BroadcastTxSweep items. */
  broadcastTxSweep(
    request: QueryBroadcastTxSweepRequest,
    callback: (error: ServiceError | null, response: QueryBroadcastTxSweepResponse) => void,
  ): ClientUnaryCall;
  broadcastTxSweep(
    request: QueryBroadcastTxSweepRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryBroadcastTxSweepResponse) => void,
  ): ClientUnaryCall;
  broadcastTxSweep(
    request: QueryBroadcastTxSweepRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryBroadcastTxSweepResponse) => void,
  ): ClientUnaryCall;
}

export const QueryClient = makeGenericClientConstructor(
  QueryService,
  "twilightproject.nyks.bridge.Query",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): QueryClient;
  service: typeof QueryService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
