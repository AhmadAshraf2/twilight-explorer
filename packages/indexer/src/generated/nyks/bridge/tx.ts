// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: nyks/bridge/tx.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "twilightproject.nyks.bridge";

export interface MsgConfirmBtcDeposit {
  reserveAddress: string;
  depositAmount: string;
  height: string;
  hash: string;
  twilightDepositAddress: string;
  oracleAddress: string;
}

export interface MsgConfirmBtcDepositResponse {
  twilightDepositAddress: string;
}

export interface MsgRegisterBtcDepositAddress {
  btcDepositAddress: string;
  btcSatoshiTestAmount: string;
  twilightStakingAmount: string;
  twilightAddress: string;
}

export interface MsgRegisterBtcDepositAddressResponse {
}

export interface MsgRegisterReserveAddress {
  fragmentId: string;
  reserveScript: string;
  reserveAddress: string;
  judgeAddress: string;
}

export interface MsgRegisterReserveAddressResponse {
  reserveId: string;
  reserveAddress: string;
}

export interface MsgBootstrapFragment {
  judgeAddress: string;
  numOfSigners: string;
  threshold: string;
  signerApplicationFee: string;
  fragmentFeeBips: string;
  arbitraryData: string;
  validatorAddress: string;
}

export interface MsgBootstrapFragmentResponse {
  fragmentId: string;
  reserveId: string;
  judgeAddress: string;
}

export interface MsgProposeRefundHash {
  refundHash: string;
  judgeAddress: string;
}

export interface MsgProposeRefundHashResponse {
}

/**
 * Withdraw messages are in below order
 * 1. MsgWithdrawBtcRequest
 */
export interface MsgWithdrawBtcRequest {
  withdrawAddress: string;
  reserveId: string;
  withdrawAmount: string;
  twilightAddress: string;
}

export interface MsgWithdrawBtcRequestResponse {
  withdrawIdentifer: number;
}

/** 2. MsgWithdrawTxSigned */
export interface MsgWithdrawTxSigned {
  creator: string;
  validatorAddress: string;
  btcTxSigned: string;
}

export interface MsgWithdrawTxSignedResponse {
}

/** 3. MsgWithdrawTxFinal */
export interface MsgWithdrawTxFinal {
  creator: string;
  judgeAddress: string;
  btcTx: string;
}

export interface MsgWithdrawTxFinalResponse {
}

/** 4. MsgConfirmBtcWithdraw */
export interface MsgConfirmBtcWithdraw {
  txHash: string;
  height: string;
  hash: string;
  judgeAddress: string;
}

export interface MsgConfirmBtcWithdrawResponse {
}

/**
 * Sweep messages in order
 * 1. MsgProposeSweepAddress
 */
export interface MsgProposeSweepAddress {
  btcAddress: string;
  btcScript: string;
  reserveId: string;
  roundId: string;
  judgeAddress: string;
}

export interface MsgProposeSweepAddressResponse {
}

/** 2. MsgUnsignedTxSweep */
export interface MsgUnsignedTxSweep {
  /** remove txid from here */
  txId: string;
  /** make txid yourself */
  btcUnsignedSweepTx: string;
  reserveId: string;
  roundId: string;
  judgeAddress: string;
}

export interface MsgUnsignedTxSweepResponse {
}

/** 3. MsgUnsignedTxRefund */
export interface MsgUnsignedTxRefund {
  reserveId: string;
  roundId: string;
  /** make txid yourself */
  btcUnsignedRefundTx: string;
  judgeAddress: string;
}

export interface MsgUnsignedTxRefundResponse {
}

/** 4. MsgSignRefund */
export interface MsgSignRefund {
  /** add txid */
  reserveId: string;
  roundId: string;
  signerPublicKey: string;
  refundSignature: string[];
  signerAddress: string;
}

export interface MsgSignRefundResponse {
}

/** 5. MsgSignSweep */
export interface MsgSignSweep {
  /** add txid */
  reserveId: string;
  roundId: string;
  signerPublicKey: string;
  sweepSignature: string[];
  signerAddress: string;
}

export interface MsgSignSweepResponse {
}

/** 6. MsgBroadcastTxRefund */
export interface MsgBroadcastTxRefund {
  reserveId: string;
  roundId: string;
  /** make txid yourself */
  signedRefundTx: string;
  judgeAddress: string;
}

export interface MsgBroadcastTxRefundResponse {
}

/** 7. MsgBroadcastTxSweep */
export interface MsgBroadcastTxSweep {
  reserveId: string;
  roundId: string;
  /** make txid yourself */
  signedSweepTx: string;
  judgeAddress: string;
}

export interface MsgBroadcastTxSweepResponse {
}

/** 8. MsgSweepProposal */
export interface MsgSweepProposal {
  reserveId: string;
  newReserveAddress: string;
  judgeAddress: string;
  BtcBlockNumber: string;
  btcRelayCapacityValue: string;
  /** rename to sweepTxId */
  btcTxHash: string;
  UnlockHeight: string;
  roundId: string;
  oracleAddress: string;
}

export interface MsgSweepProposalResponse {
}

function createBaseMsgConfirmBtcDeposit(): MsgConfirmBtcDeposit {
  return {
    reserveAddress: "",
    depositAmount: "0",
    height: "0",
    hash: "",
    twilightDepositAddress: "",
    oracleAddress: "",
  };
}

export const MsgConfirmBtcDeposit = {
  encode(message: MsgConfirmBtcDeposit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveAddress !== "") {
      writer.uint32(10).string(message.reserveAddress);
    }
    if (message.depositAmount !== "0") {
      writer.uint32(16).uint64(message.depositAmount);
    }
    if (message.height !== "0") {
      writer.uint32(24).uint64(message.height);
    }
    if (message.hash !== "") {
      writer.uint32(34).string(message.hash);
    }
    if (message.twilightDepositAddress !== "") {
      writer.uint32(42).string(message.twilightDepositAddress);
    }
    if (message.oracleAddress !== "") {
      writer.uint32(58).string(message.oracleAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgConfirmBtcDeposit {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConfirmBtcDeposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reserveAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.depositAmount = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.twilightDepositAddress = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.oracleAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgConfirmBtcDeposit {
    return {
      reserveAddress: isSet(object.reserveAddress) ? globalThis.String(object.reserveAddress) : "",
      depositAmount: isSet(object.depositAmount) ? globalThis.String(object.depositAmount) : "0",
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      twilightDepositAddress: isSet(object.twilightDepositAddress)
        ? globalThis.String(object.twilightDepositAddress)
        : "",
      oracleAddress: isSet(object.oracleAddress) ? globalThis.String(object.oracleAddress) : "",
    };
  },

  toJSON(message: MsgConfirmBtcDeposit): unknown {
    const obj: any = {};
    if (message.reserveAddress !== "") {
      obj.reserveAddress = message.reserveAddress;
    }
    if (message.depositAmount !== "0") {
      obj.depositAmount = message.depositAmount;
    }
    if (message.height !== "0") {
      obj.height = message.height;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.twilightDepositAddress !== "") {
      obj.twilightDepositAddress = message.twilightDepositAddress;
    }
    if (message.oracleAddress !== "") {
      obj.oracleAddress = message.oracleAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConfirmBtcDeposit>, I>>(base?: I): MsgConfirmBtcDeposit {
    return MsgConfirmBtcDeposit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConfirmBtcDeposit>, I>>(object: I): MsgConfirmBtcDeposit {
    const message = createBaseMsgConfirmBtcDeposit();
    message.reserveAddress = object.reserveAddress ?? "";
    message.depositAmount = object.depositAmount ?? "0";
    message.height = object.height ?? "0";
    message.hash = object.hash ?? "";
    message.twilightDepositAddress = object.twilightDepositAddress ?? "";
    message.oracleAddress = object.oracleAddress ?? "";
    return message;
  },
};

function createBaseMsgConfirmBtcDepositResponse(): MsgConfirmBtcDepositResponse {
  return { twilightDepositAddress: "" };
}

export const MsgConfirmBtcDepositResponse = {
  encode(message: MsgConfirmBtcDepositResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.twilightDepositAddress !== "") {
      writer.uint32(10).string(message.twilightDepositAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgConfirmBtcDepositResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConfirmBtcDepositResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.twilightDepositAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgConfirmBtcDepositResponse {
    return {
      twilightDepositAddress: isSet(object.twilightDepositAddress)
        ? globalThis.String(object.twilightDepositAddress)
        : "",
    };
  },

  toJSON(message: MsgConfirmBtcDepositResponse): unknown {
    const obj: any = {};
    if (message.twilightDepositAddress !== "") {
      obj.twilightDepositAddress = message.twilightDepositAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConfirmBtcDepositResponse>, I>>(base?: I): MsgConfirmBtcDepositResponse {
    return MsgConfirmBtcDepositResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConfirmBtcDepositResponse>, I>>(object: I): MsgConfirmBtcDepositResponse {
    const message = createBaseMsgConfirmBtcDepositResponse();
    message.twilightDepositAddress = object.twilightDepositAddress ?? "";
    return message;
  },
};

function createBaseMsgRegisterBtcDepositAddress(): MsgRegisterBtcDepositAddress {
  return { btcDepositAddress: "", btcSatoshiTestAmount: "0", twilightStakingAmount: "0", twilightAddress: "" };
}

export const MsgRegisterBtcDepositAddress = {
  encode(message: MsgRegisterBtcDepositAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.btcDepositAddress !== "") {
      writer.uint32(10).string(message.btcDepositAddress);
    }
    if (message.btcSatoshiTestAmount !== "0") {
      writer.uint32(16).uint64(message.btcSatoshiTestAmount);
    }
    if (message.twilightStakingAmount !== "0") {
      writer.uint32(24).uint64(message.twilightStakingAmount);
    }
    if (message.twilightAddress !== "") {
      writer.uint32(34).string(message.twilightAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRegisterBtcDepositAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterBtcDepositAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.btcDepositAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.btcSatoshiTestAmount = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.twilightStakingAmount = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.twilightAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterBtcDepositAddress {
    return {
      btcDepositAddress: isSet(object.btcDepositAddress) ? globalThis.String(object.btcDepositAddress) : "",
      btcSatoshiTestAmount: isSet(object.btcSatoshiTestAmount) ? globalThis.String(object.btcSatoshiTestAmount) : "0",
      twilightStakingAmount: isSet(object.twilightStakingAmount)
        ? globalThis.String(object.twilightStakingAmount)
        : "0",
      twilightAddress: isSet(object.twilightAddress) ? globalThis.String(object.twilightAddress) : "",
    };
  },

  toJSON(message: MsgRegisterBtcDepositAddress): unknown {
    const obj: any = {};
    if (message.btcDepositAddress !== "") {
      obj.btcDepositAddress = message.btcDepositAddress;
    }
    if (message.btcSatoshiTestAmount !== "0") {
      obj.btcSatoshiTestAmount = message.btcSatoshiTestAmount;
    }
    if (message.twilightStakingAmount !== "0") {
      obj.twilightStakingAmount = message.twilightStakingAmount;
    }
    if (message.twilightAddress !== "") {
      obj.twilightAddress = message.twilightAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterBtcDepositAddress>, I>>(base?: I): MsgRegisterBtcDepositAddress {
    return MsgRegisterBtcDepositAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterBtcDepositAddress>, I>>(object: I): MsgRegisterBtcDepositAddress {
    const message = createBaseMsgRegisterBtcDepositAddress();
    message.btcDepositAddress = object.btcDepositAddress ?? "";
    message.btcSatoshiTestAmount = object.btcSatoshiTestAmount ?? "0";
    message.twilightStakingAmount = object.twilightStakingAmount ?? "0";
    message.twilightAddress = object.twilightAddress ?? "";
    return message;
  },
};

function createBaseMsgRegisterBtcDepositAddressResponse(): MsgRegisterBtcDepositAddressResponse {
  return {};
}

export const MsgRegisterBtcDepositAddressResponse = {
  encode(_: MsgRegisterBtcDepositAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRegisterBtcDepositAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterBtcDepositAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRegisterBtcDepositAddressResponse {
    return {};
  },

  toJSON(_: MsgRegisterBtcDepositAddressResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterBtcDepositAddressResponse>, I>>(
    base?: I,
  ): MsgRegisterBtcDepositAddressResponse {
    return MsgRegisterBtcDepositAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterBtcDepositAddressResponse>, I>>(
    _: I,
  ): MsgRegisterBtcDepositAddressResponse {
    const message = createBaseMsgRegisterBtcDepositAddressResponse();
    return message;
  },
};

function createBaseMsgRegisterReserveAddress(): MsgRegisterReserveAddress {
  return { fragmentId: "0", reserveScript: "", reserveAddress: "", judgeAddress: "" };
}

export const MsgRegisterReserveAddress = {
  encode(message: MsgRegisterReserveAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fragmentId !== "0") {
      writer.uint32(8).uint64(message.fragmentId);
    }
    if (message.reserveScript !== "") {
      writer.uint32(18).string(message.reserveScript);
    }
    if (message.reserveAddress !== "") {
      writer.uint32(26).string(message.reserveAddress);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(34).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRegisterReserveAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterReserveAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fragmentId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reserveScript = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reserveAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterReserveAddress {
    return {
      fragmentId: isSet(object.fragmentId) ? globalThis.String(object.fragmentId) : "0",
      reserveScript: isSet(object.reserveScript) ? globalThis.String(object.reserveScript) : "",
      reserveAddress: isSet(object.reserveAddress) ? globalThis.String(object.reserveAddress) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgRegisterReserveAddress): unknown {
    const obj: any = {};
    if (message.fragmentId !== "0") {
      obj.fragmentId = message.fragmentId;
    }
    if (message.reserveScript !== "") {
      obj.reserveScript = message.reserveScript;
    }
    if (message.reserveAddress !== "") {
      obj.reserveAddress = message.reserveAddress;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterReserveAddress>, I>>(base?: I): MsgRegisterReserveAddress {
    return MsgRegisterReserveAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterReserveAddress>, I>>(object: I): MsgRegisterReserveAddress {
    const message = createBaseMsgRegisterReserveAddress();
    message.fragmentId = object.fragmentId ?? "0";
    message.reserveScript = object.reserveScript ?? "";
    message.reserveAddress = object.reserveAddress ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgRegisterReserveAddressResponse(): MsgRegisterReserveAddressResponse {
  return { reserveId: "", reserveAddress: "" };
}

export const MsgRegisterReserveAddressResponse = {
  encode(message: MsgRegisterReserveAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "") {
      writer.uint32(10).string(message.reserveId);
    }
    if (message.reserveAddress !== "") {
      writer.uint32(18).string(message.reserveAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgRegisterReserveAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterReserveAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reserveId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reserveAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterReserveAddressResponse {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "",
      reserveAddress: isSet(object.reserveAddress) ? globalThis.String(object.reserveAddress) : "",
    };
  },

  toJSON(message: MsgRegisterReserveAddressResponse): unknown {
    const obj: any = {};
    if (message.reserveId !== "") {
      obj.reserveId = message.reserveId;
    }
    if (message.reserveAddress !== "") {
      obj.reserveAddress = message.reserveAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterReserveAddressResponse>, I>>(
    base?: I,
  ): MsgRegisterReserveAddressResponse {
    return MsgRegisterReserveAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterReserveAddressResponse>, I>>(
    object: I,
  ): MsgRegisterReserveAddressResponse {
    const message = createBaseMsgRegisterReserveAddressResponse();
    message.reserveId = object.reserveId ?? "";
    message.reserveAddress = object.reserveAddress ?? "";
    return message;
  },
};

function createBaseMsgBootstrapFragment(): MsgBootstrapFragment {
  return {
    judgeAddress: "",
    numOfSigners: "0",
    threshold: "0",
    signerApplicationFee: "0",
    fragmentFeeBips: "0",
    arbitraryData: "",
    validatorAddress: "",
  };
}

export const MsgBootstrapFragment = {
  encode(message: MsgBootstrapFragment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.judgeAddress !== "") {
      writer.uint32(10).string(message.judgeAddress);
    }
    if (message.numOfSigners !== "0") {
      writer.uint32(16).uint64(message.numOfSigners);
    }
    if (message.threshold !== "0") {
      writer.uint32(24).uint64(message.threshold);
    }
    if (message.signerApplicationFee !== "0") {
      writer.uint32(32).uint64(message.signerApplicationFee);
    }
    if (message.fragmentFeeBips !== "0") {
      writer.uint32(40).uint64(message.fragmentFeeBips);
    }
    if (message.arbitraryData !== "") {
      writer.uint32(50).string(message.arbitraryData);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(58).string(message.validatorAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBootstrapFragment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBootstrapFragment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numOfSigners = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.threshold = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.signerApplicationFee = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fragmentFeeBips = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.arbitraryData = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBootstrapFragment {
    return {
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
      numOfSigners: isSet(object.numOfSigners) ? globalThis.String(object.numOfSigners) : "0",
      threshold: isSet(object.threshold) ? globalThis.String(object.threshold) : "0",
      signerApplicationFee: isSet(object.signerApplicationFee) ? globalThis.String(object.signerApplicationFee) : "0",
      fragmentFeeBips: isSet(object.fragmentFeeBips) ? globalThis.String(object.fragmentFeeBips) : "0",
      arbitraryData: isSet(object.arbitraryData) ? globalThis.String(object.arbitraryData) : "",
      validatorAddress: isSet(object.validatorAddress) ? globalThis.String(object.validatorAddress) : "",
    };
  },

  toJSON(message: MsgBootstrapFragment): unknown {
    const obj: any = {};
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    if (message.numOfSigners !== "0") {
      obj.numOfSigners = message.numOfSigners;
    }
    if (message.threshold !== "0") {
      obj.threshold = message.threshold;
    }
    if (message.signerApplicationFee !== "0") {
      obj.signerApplicationFee = message.signerApplicationFee;
    }
    if (message.fragmentFeeBips !== "0") {
      obj.fragmentFeeBips = message.fragmentFeeBips;
    }
    if (message.arbitraryData !== "") {
      obj.arbitraryData = message.arbitraryData;
    }
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBootstrapFragment>, I>>(base?: I): MsgBootstrapFragment {
    return MsgBootstrapFragment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBootstrapFragment>, I>>(object: I): MsgBootstrapFragment {
    const message = createBaseMsgBootstrapFragment();
    message.judgeAddress = object.judgeAddress ?? "";
    message.numOfSigners = object.numOfSigners ?? "0";
    message.threshold = object.threshold ?? "0";
    message.signerApplicationFee = object.signerApplicationFee ?? "0";
    message.fragmentFeeBips = object.fragmentFeeBips ?? "0";
    message.arbitraryData = object.arbitraryData ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    return message;
  },
};

function createBaseMsgBootstrapFragmentResponse(): MsgBootstrapFragmentResponse {
  return { fragmentId: "", reserveId: "", judgeAddress: "" };
}

export const MsgBootstrapFragmentResponse = {
  encode(message: MsgBootstrapFragmentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fragmentId !== "") {
      writer.uint32(10).string(message.fragmentId);
    }
    if (message.reserveId !== "") {
      writer.uint32(18).string(message.reserveId);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(26).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBootstrapFragmentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBootstrapFragmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fragmentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reserveId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBootstrapFragmentResponse {
    return {
      fragmentId: isSet(object.fragmentId) ? globalThis.String(object.fragmentId) : "",
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgBootstrapFragmentResponse): unknown {
    const obj: any = {};
    if (message.fragmentId !== "") {
      obj.fragmentId = message.fragmentId;
    }
    if (message.reserveId !== "") {
      obj.reserveId = message.reserveId;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBootstrapFragmentResponse>, I>>(base?: I): MsgBootstrapFragmentResponse {
    return MsgBootstrapFragmentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBootstrapFragmentResponse>, I>>(object: I): MsgBootstrapFragmentResponse {
    const message = createBaseMsgBootstrapFragmentResponse();
    message.fragmentId = object.fragmentId ?? "";
    message.reserveId = object.reserveId ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgProposeRefundHash(): MsgProposeRefundHash {
  return { refundHash: "", judgeAddress: "" };
}

export const MsgProposeRefundHash = {
  encode(message: MsgProposeRefundHash, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refundHash !== "") {
      writer.uint32(10).string(message.refundHash);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(18).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgProposeRefundHash {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposeRefundHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refundHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProposeRefundHash {
    return {
      refundHash: isSet(object.refundHash) ? globalThis.String(object.refundHash) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgProposeRefundHash): unknown {
    const obj: any = {};
    if (message.refundHash !== "") {
      obj.refundHash = message.refundHash;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProposeRefundHash>, I>>(base?: I): MsgProposeRefundHash {
    return MsgProposeRefundHash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProposeRefundHash>, I>>(object: I): MsgProposeRefundHash {
    const message = createBaseMsgProposeRefundHash();
    message.refundHash = object.refundHash ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgProposeRefundHashResponse(): MsgProposeRefundHashResponse {
  return {};
}

export const MsgProposeRefundHashResponse = {
  encode(_: MsgProposeRefundHashResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgProposeRefundHashResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposeRefundHashResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgProposeRefundHashResponse {
    return {};
  },

  toJSON(_: MsgProposeRefundHashResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProposeRefundHashResponse>, I>>(base?: I): MsgProposeRefundHashResponse {
    return MsgProposeRefundHashResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProposeRefundHashResponse>, I>>(_: I): MsgProposeRefundHashResponse {
    const message = createBaseMsgProposeRefundHashResponse();
    return message;
  },
};

function createBaseMsgWithdrawBtcRequest(): MsgWithdrawBtcRequest {
  return { withdrawAddress: "", reserveId: "0", withdrawAmount: "0", twilightAddress: "" };
}

export const MsgWithdrawBtcRequest = {
  encode(message: MsgWithdrawBtcRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.withdrawAddress !== "") {
      writer.uint32(10).string(message.withdrawAddress);
    }
    if (message.reserveId !== "0") {
      writer.uint32(16).uint64(message.reserveId);
    }
    if (message.withdrawAmount !== "0") {
      writer.uint32(24).uint64(message.withdrawAmount);
    }
    if (message.twilightAddress !== "") {
      writer.uint32(34).string(message.twilightAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawBtcRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawBtcRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.withdrawAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.withdrawAmount = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.twilightAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawBtcRequest {
    return {
      withdrawAddress: isSet(object.withdrawAddress) ? globalThis.String(object.withdrawAddress) : "",
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      withdrawAmount: isSet(object.withdrawAmount) ? globalThis.String(object.withdrawAmount) : "0",
      twilightAddress: isSet(object.twilightAddress) ? globalThis.String(object.twilightAddress) : "",
    };
  },

  toJSON(message: MsgWithdrawBtcRequest): unknown {
    const obj: any = {};
    if (message.withdrawAddress !== "") {
      obj.withdrawAddress = message.withdrawAddress;
    }
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.withdrawAmount !== "0") {
      obj.withdrawAmount = message.withdrawAmount;
    }
    if (message.twilightAddress !== "") {
      obj.twilightAddress = message.twilightAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawBtcRequest>, I>>(base?: I): MsgWithdrawBtcRequest {
    return MsgWithdrawBtcRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawBtcRequest>, I>>(object: I): MsgWithdrawBtcRequest {
    const message = createBaseMsgWithdrawBtcRequest();
    message.withdrawAddress = object.withdrawAddress ?? "";
    message.reserveId = object.reserveId ?? "0";
    message.withdrawAmount = object.withdrawAmount ?? "0";
    message.twilightAddress = object.twilightAddress ?? "";
    return message;
  },
};

function createBaseMsgWithdrawBtcRequestResponse(): MsgWithdrawBtcRequestResponse {
  return { withdrawIdentifer: 0 };
}

export const MsgWithdrawBtcRequestResponse = {
  encode(message: MsgWithdrawBtcRequestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.withdrawIdentifer !== 0) {
      writer.uint32(8).uint32(message.withdrawIdentifer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawBtcRequestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawBtcRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.withdrawIdentifer = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawBtcRequestResponse {
    return { withdrawIdentifer: isSet(object.withdrawIdentifer) ? globalThis.Number(object.withdrawIdentifer) : 0 };
  },

  toJSON(message: MsgWithdrawBtcRequestResponse): unknown {
    const obj: any = {};
    if (message.withdrawIdentifer !== 0) {
      obj.withdrawIdentifer = Math.round(message.withdrawIdentifer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawBtcRequestResponse>, I>>(base?: I): MsgWithdrawBtcRequestResponse {
    return MsgWithdrawBtcRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawBtcRequestResponse>, I>>(
    object: I,
  ): MsgWithdrawBtcRequestResponse {
    const message = createBaseMsgWithdrawBtcRequestResponse();
    message.withdrawIdentifer = object.withdrawIdentifer ?? 0;
    return message;
  },
};

function createBaseMsgWithdrawTxSigned(): MsgWithdrawTxSigned {
  return { creator: "", validatorAddress: "", btcTxSigned: "" };
}

export const MsgWithdrawTxSigned = {
  encode(message: MsgWithdrawTxSigned, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (message.btcTxSigned !== "") {
      writer.uint32(26).string(message.btcTxSigned);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawTxSigned {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawTxSigned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.btcTxSigned = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawTxSigned {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      validatorAddress: isSet(object.validatorAddress) ? globalThis.String(object.validatorAddress) : "",
      btcTxSigned: isSet(object.btcTxSigned) ? globalThis.String(object.btcTxSigned) : "",
    };
  },

  toJSON(message: MsgWithdrawTxSigned): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    if (message.btcTxSigned !== "") {
      obj.btcTxSigned = message.btcTxSigned;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawTxSigned>, I>>(base?: I): MsgWithdrawTxSigned {
    return MsgWithdrawTxSigned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawTxSigned>, I>>(object: I): MsgWithdrawTxSigned {
    const message = createBaseMsgWithdrawTxSigned();
    message.creator = object.creator ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.btcTxSigned = object.btcTxSigned ?? "";
    return message;
  },
};

function createBaseMsgWithdrawTxSignedResponse(): MsgWithdrawTxSignedResponse {
  return {};
}

export const MsgWithdrawTxSignedResponse = {
  encode(_: MsgWithdrawTxSignedResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawTxSignedResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawTxSignedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgWithdrawTxSignedResponse {
    return {};
  },

  toJSON(_: MsgWithdrawTxSignedResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawTxSignedResponse>, I>>(base?: I): MsgWithdrawTxSignedResponse {
    return MsgWithdrawTxSignedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawTxSignedResponse>, I>>(_: I): MsgWithdrawTxSignedResponse {
    const message = createBaseMsgWithdrawTxSignedResponse();
    return message;
  },
};

function createBaseMsgWithdrawTxFinal(): MsgWithdrawTxFinal {
  return { creator: "", judgeAddress: "", btcTx: "" };
}

export const MsgWithdrawTxFinal = {
  encode(message: MsgWithdrawTxFinal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(18).string(message.judgeAddress);
    }
    if (message.btcTx !== "") {
      writer.uint32(26).string(message.btcTx);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawTxFinal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawTxFinal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.btcTx = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawTxFinal {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
      btcTx: isSet(object.btcTx) ? globalThis.String(object.btcTx) : "",
    };
  },

  toJSON(message: MsgWithdrawTxFinal): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    if (message.btcTx !== "") {
      obj.btcTx = message.btcTx;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawTxFinal>, I>>(base?: I): MsgWithdrawTxFinal {
    return MsgWithdrawTxFinal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawTxFinal>, I>>(object: I): MsgWithdrawTxFinal {
    const message = createBaseMsgWithdrawTxFinal();
    message.creator = object.creator ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    message.btcTx = object.btcTx ?? "";
    return message;
  },
};

function createBaseMsgWithdrawTxFinalResponse(): MsgWithdrawTxFinalResponse {
  return {};
}

export const MsgWithdrawTxFinalResponse = {
  encode(_: MsgWithdrawTxFinalResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgWithdrawTxFinalResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawTxFinalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgWithdrawTxFinalResponse {
    return {};
  },

  toJSON(_: MsgWithdrawTxFinalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawTxFinalResponse>, I>>(base?: I): MsgWithdrawTxFinalResponse {
    return MsgWithdrawTxFinalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawTxFinalResponse>, I>>(_: I): MsgWithdrawTxFinalResponse {
    const message = createBaseMsgWithdrawTxFinalResponse();
    return message;
  },
};

function createBaseMsgConfirmBtcWithdraw(): MsgConfirmBtcWithdraw {
  return { txHash: "", height: "0", hash: "", judgeAddress: "" };
}

export const MsgConfirmBtcWithdraw = {
  encode(message: MsgConfirmBtcWithdraw, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    if (message.height !== "0") {
      writer.uint32(16).uint64(message.height);
    }
    if (message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(34).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgConfirmBtcWithdraw {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConfirmBtcWithdraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgConfirmBtcWithdraw {
    return {
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      height: isSet(object.height) ? globalThis.String(object.height) : "0",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgConfirmBtcWithdraw): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.height !== "0") {
      obj.height = message.height;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConfirmBtcWithdraw>, I>>(base?: I): MsgConfirmBtcWithdraw {
    return MsgConfirmBtcWithdraw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConfirmBtcWithdraw>, I>>(object: I): MsgConfirmBtcWithdraw {
    const message = createBaseMsgConfirmBtcWithdraw();
    message.txHash = object.txHash ?? "";
    message.height = object.height ?? "0";
    message.hash = object.hash ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgConfirmBtcWithdrawResponse(): MsgConfirmBtcWithdrawResponse {
  return {};
}

export const MsgConfirmBtcWithdrawResponse = {
  encode(_: MsgConfirmBtcWithdrawResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgConfirmBtcWithdrawResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgConfirmBtcWithdrawResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgConfirmBtcWithdrawResponse {
    return {};
  },

  toJSON(_: MsgConfirmBtcWithdrawResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgConfirmBtcWithdrawResponse>, I>>(base?: I): MsgConfirmBtcWithdrawResponse {
    return MsgConfirmBtcWithdrawResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgConfirmBtcWithdrawResponse>, I>>(_: I): MsgConfirmBtcWithdrawResponse {
    const message = createBaseMsgConfirmBtcWithdrawResponse();
    return message;
  },
};

function createBaseMsgProposeSweepAddress(): MsgProposeSweepAddress {
  return { btcAddress: "", btcScript: "", reserveId: "0", roundId: "0", judgeAddress: "" };
}

export const MsgProposeSweepAddress = {
  encode(message: MsgProposeSweepAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.btcAddress !== "") {
      writer.uint32(10).string(message.btcAddress);
    }
    if (message.btcScript !== "") {
      writer.uint32(18).string(message.btcScript);
    }
    if (message.reserveId !== "0") {
      writer.uint32(24).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(32).uint64(message.roundId);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(42).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgProposeSweepAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposeSweepAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.btcAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.btcScript = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProposeSweepAddress {
    return {
      btcAddress: isSet(object.btcAddress) ? globalThis.String(object.btcAddress) : "",
      btcScript: isSet(object.btcScript) ? globalThis.String(object.btcScript) : "",
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgProposeSweepAddress): unknown {
    const obj: any = {};
    if (message.btcAddress !== "") {
      obj.btcAddress = message.btcAddress;
    }
    if (message.btcScript !== "") {
      obj.btcScript = message.btcScript;
    }
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProposeSweepAddress>, I>>(base?: I): MsgProposeSweepAddress {
    return MsgProposeSweepAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProposeSweepAddress>, I>>(object: I): MsgProposeSweepAddress {
    const message = createBaseMsgProposeSweepAddress();
    message.btcAddress = object.btcAddress ?? "";
    message.btcScript = object.btcScript ?? "";
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgProposeSweepAddressResponse(): MsgProposeSweepAddressResponse {
  return {};
}

export const MsgProposeSweepAddressResponse = {
  encode(_: MsgProposeSweepAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgProposeSweepAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposeSweepAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgProposeSweepAddressResponse {
    return {};
  },

  toJSON(_: MsgProposeSweepAddressResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProposeSweepAddressResponse>, I>>(base?: I): MsgProposeSweepAddressResponse {
    return MsgProposeSweepAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProposeSweepAddressResponse>, I>>(_: I): MsgProposeSweepAddressResponse {
    const message = createBaseMsgProposeSweepAddressResponse();
    return message;
  },
};

function createBaseMsgUnsignedTxSweep(): MsgUnsignedTxSweep {
  return { txId: "", btcUnsignedSweepTx: "", reserveId: "0", roundId: "0", judgeAddress: "" };
}

export const MsgUnsignedTxSweep = {
  encode(message: MsgUnsignedTxSweep, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txId !== "") {
      writer.uint32(10).string(message.txId);
    }
    if (message.btcUnsignedSweepTx !== "") {
      writer.uint32(18).string(message.btcUnsignedSweepTx);
    }
    if (message.reserveId !== "0") {
      writer.uint32(24).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(32).uint64(message.roundId);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(42).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUnsignedTxSweep {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnsignedTxSweep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.btcUnsignedSweepTx = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUnsignedTxSweep {
    return {
      txId: isSet(object.txId) ? globalThis.String(object.txId) : "",
      btcUnsignedSweepTx: isSet(object.btcUnsignedSweepTx) ? globalThis.String(object.btcUnsignedSweepTx) : "",
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgUnsignedTxSweep): unknown {
    const obj: any = {};
    if (message.txId !== "") {
      obj.txId = message.txId;
    }
    if (message.btcUnsignedSweepTx !== "") {
      obj.btcUnsignedSweepTx = message.btcUnsignedSweepTx;
    }
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUnsignedTxSweep>, I>>(base?: I): MsgUnsignedTxSweep {
    return MsgUnsignedTxSweep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUnsignedTxSweep>, I>>(object: I): MsgUnsignedTxSweep {
    const message = createBaseMsgUnsignedTxSweep();
    message.txId = object.txId ?? "";
    message.btcUnsignedSweepTx = object.btcUnsignedSweepTx ?? "";
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgUnsignedTxSweepResponse(): MsgUnsignedTxSweepResponse {
  return {};
}

export const MsgUnsignedTxSweepResponse = {
  encode(_: MsgUnsignedTxSweepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUnsignedTxSweepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnsignedTxSweepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUnsignedTxSweepResponse {
    return {};
  },

  toJSON(_: MsgUnsignedTxSweepResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUnsignedTxSweepResponse>, I>>(base?: I): MsgUnsignedTxSweepResponse {
    return MsgUnsignedTxSweepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUnsignedTxSweepResponse>, I>>(_: I): MsgUnsignedTxSweepResponse {
    const message = createBaseMsgUnsignedTxSweepResponse();
    return message;
  },
};

function createBaseMsgUnsignedTxRefund(): MsgUnsignedTxRefund {
  return { reserveId: "0", roundId: "0", btcUnsignedRefundTx: "", judgeAddress: "" };
}

export const MsgUnsignedTxRefund = {
  encode(message: MsgUnsignedTxRefund, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    if (message.btcUnsignedRefundTx !== "") {
      writer.uint32(26).string(message.btcUnsignedRefundTx);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(34).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUnsignedTxRefund {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnsignedTxRefund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.btcUnsignedRefundTx = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUnsignedTxRefund {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
      btcUnsignedRefundTx: isSet(object.btcUnsignedRefundTx) ? globalThis.String(object.btcUnsignedRefundTx) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgUnsignedTxRefund): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    if (message.btcUnsignedRefundTx !== "") {
      obj.btcUnsignedRefundTx = message.btcUnsignedRefundTx;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUnsignedTxRefund>, I>>(base?: I): MsgUnsignedTxRefund {
    return MsgUnsignedTxRefund.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUnsignedTxRefund>, I>>(object: I): MsgUnsignedTxRefund {
    const message = createBaseMsgUnsignedTxRefund();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    message.btcUnsignedRefundTx = object.btcUnsignedRefundTx ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgUnsignedTxRefundResponse(): MsgUnsignedTxRefundResponse {
  return {};
}

export const MsgUnsignedTxRefundResponse = {
  encode(_: MsgUnsignedTxRefundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgUnsignedTxRefundResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnsignedTxRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUnsignedTxRefundResponse {
    return {};
  },

  toJSON(_: MsgUnsignedTxRefundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUnsignedTxRefundResponse>, I>>(base?: I): MsgUnsignedTxRefundResponse {
    return MsgUnsignedTxRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUnsignedTxRefundResponse>, I>>(_: I): MsgUnsignedTxRefundResponse {
    const message = createBaseMsgUnsignedTxRefundResponse();
    return message;
  },
};

function createBaseMsgSignRefund(): MsgSignRefund {
  return { reserveId: "0", roundId: "0", signerPublicKey: "", refundSignature: [], signerAddress: "" };
}

export const MsgSignRefund = {
  encode(message: MsgSignRefund, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    if (message.signerPublicKey !== "") {
      writer.uint32(26).string(message.signerPublicKey);
    }
    for (const v of message.refundSignature) {
      writer.uint32(34).string(v!);
    }
    if (message.signerAddress !== "") {
      writer.uint32(42).string(message.signerAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSignRefund {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSignRefund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signerPublicKey = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.refundSignature.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.signerAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSignRefund {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
      signerPublicKey: isSet(object.signerPublicKey) ? globalThis.String(object.signerPublicKey) : "",
      refundSignature: globalThis.Array.isArray(object?.refundSignature)
        ? object.refundSignature.map((e: any) => globalThis.String(e))
        : [],
      signerAddress: isSet(object.signerAddress) ? globalThis.String(object.signerAddress) : "",
    };
  },

  toJSON(message: MsgSignRefund): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    if (message.signerPublicKey !== "") {
      obj.signerPublicKey = message.signerPublicKey;
    }
    if (message.refundSignature?.length) {
      obj.refundSignature = message.refundSignature;
    }
    if (message.signerAddress !== "") {
      obj.signerAddress = message.signerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSignRefund>, I>>(base?: I): MsgSignRefund {
    return MsgSignRefund.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSignRefund>, I>>(object: I): MsgSignRefund {
    const message = createBaseMsgSignRefund();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    message.signerPublicKey = object.signerPublicKey ?? "";
    message.refundSignature = object.refundSignature?.map((e) => e) || [];
    message.signerAddress = object.signerAddress ?? "";
    return message;
  },
};

function createBaseMsgSignRefundResponse(): MsgSignRefundResponse {
  return {};
}

export const MsgSignRefundResponse = {
  encode(_: MsgSignRefundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSignRefundResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSignRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSignRefundResponse {
    return {};
  },

  toJSON(_: MsgSignRefundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSignRefundResponse>, I>>(base?: I): MsgSignRefundResponse {
    return MsgSignRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSignRefundResponse>, I>>(_: I): MsgSignRefundResponse {
    const message = createBaseMsgSignRefundResponse();
    return message;
  },
};

function createBaseMsgSignSweep(): MsgSignSweep {
  return { reserveId: "0", roundId: "0", signerPublicKey: "", sweepSignature: [], signerAddress: "" };
}

export const MsgSignSweep = {
  encode(message: MsgSignSweep, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    if (message.signerPublicKey !== "") {
      writer.uint32(26).string(message.signerPublicKey);
    }
    for (const v of message.sweepSignature) {
      writer.uint32(34).string(v!);
    }
    if (message.signerAddress !== "") {
      writer.uint32(42).string(message.signerAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSignSweep {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSignSweep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signerPublicKey = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sweepSignature.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.signerAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSignSweep {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
      signerPublicKey: isSet(object.signerPublicKey) ? globalThis.String(object.signerPublicKey) : "",
      sweepSignature: globalThis.Array.isArray(object?.sweepSignature)
        ? object.sweepSignature.map((e: any) => globalThis.String(e))
        : [],
      signerAddress: isSet(object.signerAddress) ? globalThis.String(object.signerAddress) : "",
    };
  },

  toJSON(message: MsgSignSweep): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    if (message.signerPublicKey !== "") {
      obj.signerPublicKey = message.signerPublicKey;
    }
    if (message.sweepSignature?.length) {
      obj.sweepSignature = message.sweepSignature;
    }
    if (message.signerAddress !== "") {
      obj.signerAddress = message.signerAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSignSweep>, I>>(base?: I): MsgSignSweep {
    return MsgSignSweep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSignSweep>, I>>(object: I): MsgSignSweep {
    const message = createBaseMsgSignSweep();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    message.signerPublicKey = object.signerPublicKey ?? "";
    message.sweepSignature = object.sweepSignature?.map((e) => e) || [];
    message.signerAddress = object.signerAddress ?? "";
    return message;
  },
};

function createBaseMsgSignSweepResponse(): MsgSignSweepResponse {
  return {};
}

export const MsgSignSweepResponse = {
  encode(_: MsgSignSweepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSignSweepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSignSweepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSignSweepResponse {
    return {};
  },

  toJSON(_: MsgSignSweepResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSignSweepResponse>, I>>(base?: I): MsgSignSweepResponse {
    return MsgSignSweepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSignSweepResponse>, I>>(_: I): MsgSignSweepResponse {
    const message = createBaseMsgSignSweepResponse();
    return message;
  },
};

function createBaseMsgBroadcastTxRefund(): MsgBroadcastTxRefund {
  return { reserveId: "0", roundId: "0", signedRefundTx: "", judgeAddress: "" };
}

export const MsgBroadcastTxRefund = {
  encode(message: MsgBroadcastTxRefund, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    if (message.signedRefundTx !== "") {
      writer.uint32(26).string(message.signedRefundTx);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(34).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBroadcastTxRefund {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBroadcastTxRefund();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signedRefundTx = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBroadcastTxRefund {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
      signedRefundTx: isSet(object.signedRefundTx) ? globalThis.String(object.signedRefundTx) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgBroadcastTxRefund): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    if (message.signedRefundTx !== "") {
      obj.signedRefundTx = message.signedRefundTx;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBroadcastTxRefund>, I>>(base?: I): MsgBroadcastTxRefund {
    return MsgBroadcastTxRefund.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBroadcastTxRefund>, I>>(object: I): MsgBroadcastTxRefund {
    const message = createBaseMsgBroadcastTxRefund();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    message.signedRefundTx = object.signedRefundTx ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgBroadcastTxRefundResponse(): MsgBroadcastTxRefundResponse {
  return {};
}

export const MsgBroadcastTxRefundResponse = {
  encode(_: MsgBroadcastTxRefundResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBroadcastTxRefundResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBroadcastTxRefundResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBroadcastTxRefundResponse {
    return {};
  },

  toJSON(_: MsgBroadcastTxRefundResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBroadcastTxRefundResponse>, I>>(base?: I): MsgBroadcastTxRefundResponse {
    return MsgBroadcastTxRefundResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBroadcastTxRefundResponse>, I>>(_: I): MsgBroadcastTxRefundResponse {
    const message = createBaseMsgBroadcastTxRefundResponse();
    return message;
  },
};

function createBaseMsgBroadcastTxSweep(): MsgBroadcastTxSweep {
  return { reserveId: "0", roundId: "0", signedSweepTx: "", judgeAddress: "" };
}

export const MsgBroadcastTxSweep = {
  encode(message: MsgBroadcastTxSweep, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    if (message.signedSweepTx !== "") {
      writer.uint32(26).string(message.signedSweepTx);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(34).string(message.judgeAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBroadcastTxSweep {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBroadcastTxSweep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signedSweepTx = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBroadcastTxSweep {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
      signedSweepTx: isSet(object.signedSweepTx) ? globalThis.String(object.signedSweepTx) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
    };
  },

  toJSON(message: MsgBroadcastTxSweep): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    if (message.signedSweepTx !== "") {
      obj.signedSweepTx = message.signedSweepTx;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBroadcastTxSweep>, I>>(base?: I): MsgBroadcastTxSweep {
    return MsgBroadcastTxSweep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBroadcastTxSweep>, I>>(object: I): MsgBroadcastTxSweep {
    const message = createBaseMsgBroadcastTxSweep();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    message.signedSweepTx = object.signedSweepTx ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    return message;
  },
};

function createBaseMsgBroadcastTxSweepResponse(): MsgBroadcastTxSweepResponse {
  return {};
}

export const MsgBroadcastTxSweepResponse = {
  encode(_: MsgBroadcastTxSweepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgBroadcastTxSweepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBroadcastTxSweepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBroadcastTxSweepResponse {
    return {};
  },

  toJSON(_: MsgBroadcastTxSweepResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBroadcastTxSweepResponse>, I>>(base?: I): MsgBroadcastTxSweepResponse {
    return MsgBroadcastTxSweepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBroadcastTxSweepResponse>, I>>(_: I): MsgBroadcastTxSweepResponse {
    const message = createBaseMsgBroadcastTxSweepResponse();
    return message;
  },
};

function createBaseMsgSweepProposal(): MsgSweepProposal {
  return {
    reserveId: "0",
    newReserveAddress: "",
    judgeAddress: "",
    BtcBlockNumber: "0",
    btcRelayCapacityValue: "0",
    btcTxHash: "",
    UnlockHeight: "0",
    roundId: "0",
    oracleAddress: "",
  };
}

export const MsgSweepProposal = {
  encode(message: MsgSweepProposal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.newReserveAddress !== "") {
      writer.uint32(18).string(message.newReserveAddress);
    }
    if (message.judgeAddress !== "") {
      writer.uint32(26).string(message.judgeAddress);
    }
    if (message.BtcBlockNumber !== "0") {
      writer.uint32(32).uint64(message.BtcBlockNumber);
    }
    if (message.btcRelayCapacityValue !== "0") {
      writer.uint32(40).uint64(message.btcRelayCapacityValue);
    }
    if (message.btcTxHash !== "") {
      writer.uint32(50).string(message.btcTxHash);
    }
    if (message.UnlockHeight !== "0") {
      writer.uint32(56).uint64(message.UnlockHeight);
    }
    if (message.roundId !== "0") {
      writer.uint32(64).uint64(message.roundId);
    }
    if (message.oracleAddress !== "") {
      writer.uint32(74).string(message.oracleAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSweepProposal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSweepProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newReserveAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.judgeAddress = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.BtcBlockNumber = longToString(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.btcRelayCapacityValue = longToString(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.btcTxHash = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.UnlockHeight = longToString(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.oracleAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSweepProposal {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      newReserveAddress: isSet(object.newReserveAddress) ? globalThis.String(object.newReserveAddress) : "",
      judgeAddress: isSet(object.judgeAddress) ? globalThis.String(object.judgeAddress) : "",
      BtcBlockNumber: isSet(object.BtcBlockNumber) ? globalThis.String(object.BtcBlockNumber) : "0",
      btcRelayCapacityValue: isSet(object.btcRelayCapacityValue)
        ? globalThis.String(object.btcRelayCapacityValue)
        : "0",
      btcTxHash: isSet(object.btcTxHash) ? globalThis.String(object.btcTxHash) : "",
      UnlockHeight: isSet(object.UnlockHeight) ? globalThis.String(object.UnlockHeight) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
      oracleAddress: isSet(object.oracleAddress) ? globalThis.String(object.oracleAddress) : "",
    };
  },

  toJSON(message: MsgSweepProposal): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.newReserveAddress !== "") {
      obj.newReserveAddress = message.newReserveAddress;
    }
    if (message.judgeAddress !== "") {
      obj.judgeAddress = message.judgeAddress;
    }
    if (message.BtcBlockNumber !== "0") {
      obj.BtcBlockNumber = message.BtcBlockNumber;
    }
    if (message.btcRelayCapacityValue !== "0") {
      obj.btcRelayCapacityValue = message.btcRelayCapacityValue;
    }
    if (message.btcTxHash !== "") {
      obj.btcTxHash = message.btcTxHash;
    }
    if (message.UnlockHeight !== "0") {
      obj.UnlockHeight = message.UnlockHeight;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    if (message.oracleAddress !== "") {
      obj.oracleAddress = message.oracleAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSweepProposal>, I>>(base?: I): MsgSweepProposal {
    return MsgSweepProposal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSweepProposal>, I>>(object: I): MsgSweepProposal {
    const message = createBaseMsgSweepProposal();
    message.reserveId = object.reserveId ?? "0";
    message.newReserveAddress = object.newReserveAddress ?? "";
    message.judgeAddress = object.judgeAddress ?? "";
    message.BtcBlockNumber = object.BtcBlockNumber ?? "0";
    message.btcRelayCapacityValue = object.btcRelayCapacityValue ?? "0";
    message.btcTxHash = object.btcTxHash ?? "";
    message.UnlockHeight = object.UnlockHeight ?? "0";
    message.roundId = object.roundId ?? "0";
    message.oracleAddress = object.oracleAddress ?? "";
    return message;
  },
};

function createBaseMsgSweepProposalResponse(): MsgSweepProposalResponse {
  return {};
}

export const MsgSweepProposalResponse = {
  encode(_: MsgSweepProposalResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MsgSweepProposalResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSweepProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSweepProposalResponse {
    return {};
  },

  toJSON(_: MsgSweepProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSweepProposalResponse>, I>>(base?: I): MsgSweepProposalResponse {
    return MsgSweepProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSweepProposalResponse>, I>>(_: I): MsgSweepProposalResponse {
    const message = createBaseMsgSweepProposalResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export type MsgService = typeof MsgService;
export const MsgService = {
  confirmBtcDeposit: {
    path: "/twilightproject.nyks.bridge.Msg/ConfirmBtcDeposit",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgConfirmBtcDeposit) => Buffer.from(MsgConfirmBtcDeposit.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgConfirmBtcDeposit.decode(value),
    responseSerialize: (value: MsgConfirmBtcDepositResponse) =>
      Buffer.from(MsgConfirmBtcDepositResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgConfirmBtcDepositResponse.decode(value),
  },
  registerBtcDepositAddress: {
    path: "/twilightproject.nyks.bridge.Msg/RegisterBtcDepositAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgRegisterBtcDepositAddress) =>
      Buffer.from(MsgRegisterBtcDepositAddress.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgRegisterBtcDepositAddress.decode(value),
    responseSerialize: (value: MsgRegisterBtcDepositAddressResponse) =>
      Buffer.from(MsgRegisterBtcDepositAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgRegisterBtcDepositAddressResponse.decode(value),
  },
  registerReserveAddress: {
    path: "/twilightproject.nyks.bridge.Msg/RegisterReserveAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgRegisterReserveAddress) =>
      Buffer.from(MsgRegisterReserveAddress.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgRegisterReserveAddress.decode(value),
    responseSerialize: (value: MsgRegisterReserveAddressResponse) =>
      Buffer.from(MsgRegisterReserveAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgRegisterReserveAddressResponse.decode(value),
  },
  bootstrapFragment: {
    path: "/twilightproject.nyks.bridge.Msg/BootstrapFragment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgBootstrapFragment) => Buffer.from(MsgBootstrapFragment.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgBootstrapFragment.decode(value),
    responseSerialize: (value: MsgBootstrapFragmentResponse) =>
      Buffer.from(MsgBootstrapFragmentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgBootstrapFragmentResponse.decode(value),
  },
  /** this line is used by starport scaffolding # proto/tx/rpc */
  withdrawBtcRequest: {
    path: "/twilightproject.nyks.bridge.Msg/WithdrawBtcRequest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgWithdrawBtcRequest) => Buffer.from(MsgWithdrawBtcRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgWithdrawBtcRequest.decode(value),
    responseSerialize: (value: MsgWithdrawBtcRequestResponse) =>
      Buffer.from(MsgWithdrawBtcRequestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgWithdrawBtcRequestResponse.decode(value),
  },
  sweepProposal: {
    path: "/twilightproject.nyks.bridge.Msg/SweepProposal",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgSweepProposal) => Buffer.from(MsgSweepProposal.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgSweepProposal.decode(value),
    responseSerialize: (value: MsgSweepProposalResponse) =>
      Buffer.from(MsgSweepProposalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgSweepProposalResponse.decode(value),
  },
  withdrawTxSigned: {
    path: "/twilightproject.nyks.bridge.Msg/WithdrawTxSigned",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgWithdrawTxSigned) => Buffer.from(MsgWithdrawTxSigned.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgWithdrawTxSigned.decode(value),
    responseSerialize: (value: MsgWithdrawTxSignedResponse) =>
      Buffer.from(MsgWithdrawTxSignedResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgWithdrawTxSignedResponse.decode(value),
  },
  withdrawTxFinal: {
    path: "/twilightproject.nyks.bridge.Msg/WithdrawTxFinal",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgWithdrawTxFinal) => Buffer.from(MsgWithdrawTxFinal.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgWithdrawTxFinal.decode(value),
    responseSerialize: (value: MsgWithdrawTxFinalResponse) =>
      Buffer.from(MsgWithdrawTxFinalResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgWithdrawTxFinalResponse.decode(value),
  },
  signRefund: {
    path: "/twilightproject.nyks.bridge.Msg/SignRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgSignRefund) => Buffer.from(MsgSignRefund.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgSignRefund.decode(value),
    responseSerialize: (value: MsgSignRefundResponse) => Buffer.from(MsgSignRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgSignRefundResponse.decode(value),
  },
  broadcastTxSweep: {
    path: "/twilightproject.nyks.bridge.Msg/BroadcastTxSweep",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgBroadcastTxSweep) => Buffer.from(MsgBroadcastTxSweep.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgBroadcastTxSweep.decode(value),
    responseSerialize: (value: MsgBroadcastTxSweepResponse) =>
      Buffer.from(MsgBroadcastTxSweepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgBroadcastTxSweepResponse.decode(value),
  },
  signSweep: {
    path: "/twilightproject.nyks.bridge.Msg/SignSweep",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgSignSweep) => Buffer.from(MsgSignSweep.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgSignSweep.decode(value),
    responseSerialize: (value: MsgSignSweepResponse) => Buffer.from(MsgSignSweepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgSignSweepResponse.decode(value),
  },
  proposeRefundHash: {
    path: "/twilightproject.nyks.bridge.Msg/ProposeRefundHash",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgProposeRefundHash) => Buffer.from(MsgProposeRefundHash.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgProposeRefundHash.decode(value),
    responseSerialize: (value: MsgProposeRefundHashResponse) =>
      Buffer.from(MsgProposeRefundHashResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgProposeRefundHashResponse.decode(value),
  },
  confirmBtcWithdraw: {
    path: "/twilightproject.nyks.bridge.Msg/ConfirmBtcWithdraw",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgConfirmBtcWithdraw) => Buffer.from(MsgConfirmBtcWithdraw.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgConfirmBtcWithdraw.decode(value),
    responseSerialize: (value: MsgConfirmBtcWithdrawResponse) =>
      Buffer.from(MsgConfirmBtcWithdrawResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgConfirmBtcWithdrawResponse.decode(value),
  },
  unsignedTxSweep: {
    path: "/twilightproject.nyks.bridge.Msg/UnsignedTxSweep",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgUnsignedTxSweep) => Buffer.from(MsgUnsignedTxSweep.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgUnsignedTxSweep.decode(value),
    responseSerialize: (value: MsgUnsignedTxSweepResponse) =>
      Buffer.from(MsgUnsignedTxSweepResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgUnsignedTxSweepResponse.decode(value),
  },
  unsignedTxRefund: {
    path: "/twilightproject.nyks.bridge.Msg/UnsignedTxRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgUnsignedTxRefund) => Buffer.from(MsgUnsignedTxRefund.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgUnsignedTxRefund.decode(value),
    responseSerialize: (value: MsgUnsignedTxRefundResponse) =>
      Buffer.from(MsgUnsignedTxRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgUnsignedTxRefundResponse.decode(value),
  },
  broadcastTxRefund: {
    path: "/twilightproject.nyks.bridge.Msg/BroadcastTxRefund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgBroadcastTxRefund) => Buffer.from(MsgBroadcastTxRefund.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgBroadcastTxRefund.decode(value),
    responseSerialize: (value: MsgBroadcastTxRefundResponse) =>
      Buffer.from(MsgBroadcastTxRefundResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgBroadcastTxRefundResponse.decode(value),
  },
  proposeSweepAddress: {
    path: "/twilightproject.nyks.bridge.Msg/ProposeSweepAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MsgProposeSweepAddress) => Buffer.from(MsgProposeSweepAddress.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MsgProposeSweepAddress.decode(value),
    responseSerialize: (value: MsgProposeSweepAddressResponse) =>
      Buffer.from(MsgProposeSweepAddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MsgProposeSweepAddressResponse.decode(value),
  },
} as const;

export interface MsgServer extends UntypedServiceImplementation {
  confirmBtcDeposit: handleUnaryCall<MsgConfirmBtcDeposit, MsgConfirmBtcDepositResponse>;
  registerBtcDepositAddress: handleUnaryCall<MsgRegisterBtcDepositAddress, MsgRegisterBtcDepositAddressResponse>;
  registerReserveAddress: handleUnaryCall<MsgRegisterReserveAddress, MsgRegisterReserveAddressResponse>;
  bootstrapFragment: handleUnaryCall<MsgBootstrapFragment, MsgBootstrapFragmentResponse>;
  /** this line is used by starport scaffolding # proto/tx/rpc */
  withdrawBtcRequest: handleUnaryCall<MsgWithdrawBtcRequest, MsgWithdrawBtcRequestResponse>;
  sweepProposal: handleUnaryCall<MsgSweepProposal, MsgSweepProposalResponse>;
  withdrawTxSigned: handleUnaryCall<MsgWithdrawTxSigned, MsgWithdrawTxSignedResponse>;
  withdrawTxFinal: handleUnaryCall<MsgWithdrawTxFinal, MsgWithdrawTxFinalResponse>;
  signRefund: handleUnaryCall<MsgSignRefund, MsgSignRefundResponse>;
  broadcastTxSweep: handleUnaryCall<MsgBroadcastTxSweep, MsgBroadcastTxSweepResponse>;
  signSweep: handleUnaryCall<MsgSignSweep, MsgSignSweepResponse>;
  proposeRefundHash: handleUnaryCall<MsgProposeRefundHash, MsgProposeRefundHashResponse>;
  confirmBtcWithdraw: handleUnaryCall<MsgConfirmBtcWithdraw, MsgConfirmBtcWithdrawResponse>;
  unsignedTxSweep: handleUnaryCall<MsgUnsignedTxSweep, MsgUnsignedTxSweepResponse>;
  unsignedTxRefund: handleUnaryCall<MsgUnsignedTxRefund, MsgUnsignedTxRefundResponse>;
  broadcastTxRefund: handleUnaryCall<MsgBroadcastTxRefund, MsgBroadcastTxRefundResponse>;
  proposeSweepAddress: handleUnaryCall<MsgProposeSweepAddress, MsgProposeSweepAddressResponse>;
}

export interface MsgClient extends Client {
  confirmBtcDeposit(
    request: MsgConfirmBtcDeposit,
    callback: (error: ServiceError | null, response: MsgConfirmBtcDepositResponse) => void,
  ): ClientUnaryCall;
  confirmBtcDeposit(
    request: MsgConfirmBtcDeposit,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgConfirmBtcDepositResponse) => void,
  ): ClientUnaryCall;
  confirmBtcDeposit(
    request: MsgConfirmBtcDeposit,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgConfirmBtcDepositResponse) => void,
  ): ClientUnaryCall;
  registerBtcDepositAddress(
    request: MsgRegisterBtcDepositAddress,
    callback: (error: ServiceError | null, response: MsgRegisterBtcDepositAddressResponse) => void,
  ): ClientUnaryCall;
  registerBtcDepositAddress(
    request: MsgRegisterBtcDepositAddress,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgRegisterBtcDepositAddressResponse) => void,
  ): ClientUnaryCall;
  registerBtcDepositAddress(
    request: MsgRegisterBtcDepositAddress,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgRegisterBtcDepositAddressResponse) => void,
  ): ClientUnaryCall;
  registerReserveAddress(
    request: MsgRegisterReserveAddress,
    callback: (error: ServiceError | null, response: MsgRegisterReserveAddressResponse) => void,
  ): ClientUnaryCall;
  registerReserveAddress(
    request: MsgRegisterReserveAddress,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgRegisterReserveAddressResponse) => void,
  ): ClientUnaryCall;
  registerReserveAddress(
    request: MsgRegisterReserveAddress,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgRegisterReserveAddressResponse) => void,
  ): ClientUnaryCall;
  bootstrapFragment(
    request: MsgBootstrapFragment,
    callback: (error: ServiceError | null, response: MsgBootstrapFragmentResponse) => void,
  ): ClientUnaryCall;
  bootstrapFragment(
    request: MsgBootstrapFragment,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgBootstrapFragmentResponse) => void,
  ): ClientUnaryCall;
  bootstrapFragment(
    request: MsgBootstrapFragment,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgBootstrapFragmentResponse) => void,
  ): ClientUnaryCall;
  /** this line is used by starport scaffolding # proto/tx/rpc */
  withdrawBtcRequest(
    request: MsgWithdrawBtcRequest,
    callback: (error: ServiceError | null, response: MsgWithdrawBtcRequestResponse) => void,
  ): ClientUnaryCall;
  withdrawBtcRequest(
    request: MsgWithdrawBtcRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgWithdrawBtcRequestResponse) => void,
  ): ClientUnaryCall;
  withdrawBtcRequest(
    request: MsgWithdrawBtcRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgWithdrawBtcRequestResponse) => void,
  ): ClientUnaryCall;
  sweepProposal(
    request: MsgSweepProposal,
    callback: (error: ServiceError | null, response: MsgSweepProposalResponse) => void,
  ): ClientUnaryCall;
  sweepProposal(
    request: MsgSweepProposal,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgSweepProposalResponse) => void,
  ): ClientUnaryCall;
  sweepProposal(
    request: MsgSweepProposal,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgSweepProposalResponse) => void,
  ): ClientUnaryCall;
  withdrawTxSigned(
    request: MsgWithdrawTxSigned,
    callback: (error: ServiceError | null, response: MsgWithdrawTxSignedResponse) => void,
  ): ClientUnaryCall;
  withdrawTxSigned(
    request: MsgWithdrawTxSigned,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgWithdrawTxSignedResponse) => void,
  ): ClientUnaryCall;
  withdrawTxSigned(
    request: MsgWithdrawTxSigned,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgWithdrawTxSignedResponse) => void,
  ): ClientUnaryCall;
  withdrawTxFinal(
    request: MsgWithdrawTxFinal,
    callback: (error: ServiceError | null, response: MsgWithdrawTxFinalResponse) => void,
  ): ClientUnaryCall;
  withdrawTxFinal(
    request: MsgWithdrawTxFinal,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgWithdrawTxFinalResponse) => void,
  ): ClientUnaryCall;
  withdrawTxFinal(
    request: MsgWithdrawTxFinal,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgWithdrawTxFinalResponse) => void,
  ): ClientUnaryCall;
  signRefund(
    request: MsgSignRefund,
    callback: (error: ServiceError | null, response: MsgSignRefundResponse) => void,
  ): ClientUnaryCall;
  signRefund(
    request: MsgSignRefund,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgSignRefundResponse) => void,
  ): ClientUnaryCall;
  signRefund(
    request: MsgSignRefund,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgSignRefundResponse) => void,
  ): ClientUnaryCall;
  broadcastTxSweep(
    request: MsgBroadcastTxSweep,
    callback: (error: ServiceError | null, response: MsgBroadcastTxSweepResponse) => void,
  ): ClientUnaryCall;
  broadcastTxSweep(
    request: MsgBroadcastTxSweep,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgBroadcastTxSweepResponse) => void,
  ): ClientUnaryCall;
  broadcastTxSweep(
    request: MsgBroadcastTxSweep,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgBroadcastTxSweepResponse) => void,
  ): ClientUnaryCall;
  signSweep(
    request: MsgSignSweep,
    callback: (error: ServiceError | null, response: MsgSignSweepResponse) => void,
  ): ClientUnaryCall;
  signSweep(
    request: MsgSignSweep,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgSignSweepResponse) => void,
  ): ClientUnaryCall;
  signSweep(
    request: MsgSignSweep,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgSignSweepResponse) => void,
  ): ClientUnaryCall;
  proposeRefundHash(
    request: MsgProposeRefundHash,
    callback: (error: ServiceError | null, response: MsgProposeRefundHashResponse) => void,
  ): ClientUnaryCall;
  proposeRefundHash(
    request: MsgProposeRefundHash,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgProposeRefundHashResponse) => void,
  ): ClientUnaryCall;
  proposeRefundHash(
    request: MsgProposeRefundHash,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgProposeRefundHashResponse) => void,
  ): ClientUnaryCall;
  confirmBtcWithdraw(
    request: MsgConfirmBtcWithdraw,
    callback: (error: ServiceError | null, response: MsgConfirmBtcWithdrawResponse) => void,
  ): ClientUnaryCall;
  confirmBtcWithdraw(
    request: MsgConfirmBtcWithdraw,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgConfirmBtcWithdrawResponse) => void,
  ): ClientUnaryCall;
  confirmBtcWithdraw(
    request: MsgConfirmBtcWithdraw,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgConfirmBtcWithdrawResponse) => void,
  ): ClientUnaryCall;
  unsignedTxSweep(
    request: MsgUnsignedTxSweep,
    callback: (error: ServiceError | null, response: MsgUnsignedTxSweepResponse) => void,
  ): ClientUnaryCall;
  unsignedTxSweep(
    request: MsgUnsignedTxSweep,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgUnsignedTxSweepResponse) => void,
  ): ClientUnaryCall;
  unsignedTxSweep(
    request: MsgUnsignedTxSweep,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgUnsignedTxSweepResponse) => void,
  ): ClientUnaryCall;
  unsignedTxRefund(
    request: MsgUnsignedTxRefund,
    callback: (error: ServiceError | null, response: MsgUnsignedTxRefundResponse) => void,
  ): ClientUnaryCall;
  unsignedTxRefund(
    request: MsgUnsignedTxRefund,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgUnsignedTxRefundResponse) => void,
  ): ClientUnaryCall;
  unsignedTxRefund(
    request: MsgUnsignedTxRefund,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgUnsignedTxRefundResponse) => void,
  ): ClientUnaryCall;
  broadcastTxRefund(
    request: MsgBroadcastTxRefund,
    callback: (error: ServiceError | null, response: MsgBroadcastTxRefundResponse) => void,
  ): ClientUnaryCall;
  broadcastTxRefund(
    request: MsgBroadcastTxRefund,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgBroadcastTxRefundResponse) => void,
  ): ClientUnaryCall;
  broadcastTxRefund(
    request: MsgBroadcastTxRefund,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgBroadcastTxRefundResponse) => void,
  ): ClientUnaryCall;
  proposeSweepAddress(
    request: MsgProposeSweepAddress,
    callback: (error: ServiceError | null, response: MsgProposeSweepAddressResponse) => void,
  ): ClientUnaryCall;
  proposeSweepAddress(
    request: MsgProposeSweepAddress,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MsgProposeSweepAddressResponse) => void,
  ): ClientUnaryCall;
  proposeSweepAddress(
    request: MsgProposeSweepAddress,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MsgProposeSweepAddressResponse) => void,
  ): ClientUnaryCall;
}

export const MsgClient = makeGenericClientConstructor(MsgService, "twilightproject.nyks.bridge.Msg") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): MsgClient;
  service: typeof MsgService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
