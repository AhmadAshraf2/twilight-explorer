// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: nyks/volt/query.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { ClearingAccount, RefundTxSnapshot } from "./clearing";
import { Fragment, SignerApplication } from "./fragment";
import { Params } from "./params";
import { BtcReserve } from "./reserve";
import { BtcWithdrawRequestInternal, ReserveWithdrawPool, ReserveWithdrawSnapshot } from "./withdraw";

export const protobufPackage = "twilightproject.nyks.volt";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params?: Params | undefined;
}

export interface QueryBtcReserveRequest {
}

export interface QueryBtcReserveResponse {
  BtcReserves: BtcReserve[];
}

/** this line is used by starport scaffolding # 3 */
export interface QueryClearingAccountRequest {
  twilightAddress: string;
}

export interface QueryClearingAccountResponse {
  ClearingAccount?: ClearingAccount | undefined;
}

export interface QueryReserveClearingAccountsAllRequest {
  reserveId: string;
}

export interface QueryReserveClearingAccountsAllResponse {
  ReserveClearingAccountsAll: ClearingAccount[];
}

export interface QueryReserveWithdrawSnapshotRequest {
  reserveId: string;
  roundId: string;
}

export interface QueryReserveWithdrawSnapshotResponse {
  ReserveWithdrawSnapshot?: ReserveWithdrawSnapshot | undefined;
}

export interface QueryRefundTxSnapshotRequest {
  reserveId: string;
  roundId: string;
}

export interface QueryRefundTxSnapshotResponse {
  RefundTxSnapshot?: RefundTxSnapshot | undefined;
}

export interface QueryBtcWithdrawRequestRequest {
  twilightAddress: string;
  reserveId: string;
  btcAddress: string;
  withdrawAmount: string;
}

export interface QueryBtcWithdrawRequestResponse {
  BtcWithdrawRequest?: BtcWithdrawRequestInternal | undefined;
}

export interface QueryReserveWithdrawPoolRequest {
  reserveId: string;
}

export interface QueryReserveWithdrawPoolResponse {
  ReserveWithdrawPool?: ReserveWithdrawPool | undefined;
}

export interface QueryFragmentByIdRequest {
  fragmentId: string;
}

export interface QueryFragmentByIdResponse {
  Fragment?: Fragment | undefined;
}

export interface QueryGetAllFragmentsRequest {
}

export interface QueryGetAllFragmentsResponse {
  Fragments: Fragment[];
}

export interface QuerySignerApplicationsRequest {
  fragmentId: string;
}

export interface QuerySignerApplicationsResponse {
  SignerApplications: SignerApplication[];
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest = {
  encode(_: QueryParamsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse = {
  encode(message: QueryParamsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryBtcReserveRequest(): QueryBtcReserveRequest {
  return {};
}

export const QueryBtcReserveRequest = {
  encode(_: QueryBtcReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBtcReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBtcReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryBtcReserveRequest {
    return {};
  },

  toJSON(_: QueryBtcReserveRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBtcReserveRequest>, I>>(base?: I): QueryBtcReserveRequest {
    return QueryBtcReserveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBtcReserveRequest>, I>>(_: I): QueryBtcReserveRequest {
    const message = createBaseQueryBtcReserveRequest();
    return message;
  },
};

function createBaseQueryBtcReserveResponse(): QueryBtcReserveResponse {
  return { BtcReserves: [] };
}

export const QueryBtcReserveResponse = {
  encode(message: QueryBtcReserveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.BtcReserves) {
      BtcReserve.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBtcReserveResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBtcReserveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.BtcReserves.push(BtcReserve.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBtcReserveResponse {
    return {
      BtcReserves: globalThis.Array.isArray(object?.BtcReserves)
        ? object.BtcReserves.map((e: any) => BtcReserve.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBtcReserveResponse): unknown {
    const obj: any = {};
    if (message.BtcReserves?.length) {
      obj.BtcReserves = message.BtcReserves.map((e) => BtcReserve.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBtcReserveResponse>, I>>(base?: I): QueryBtcReserveResponse {
    return QueryBtcReserveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBtcReserveResponse>, I>>(object: I): QueryBtcReserveResponse {
    const message = createBaseQueryBtcReserveResponse();
    message.BtcReserves = object.BtcReserves?.map((e) => BtcReserve.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryClearingAccountRequest(): QueryClearingAccountRequest {
  return { twilightAddress: "" };
}

export const QueryClearingAccountRequest = {
  encode(message: QueryClearingAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.twilightAddress !== "") {
      writer.uint32(10).string(message.twilightAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryClearingAccountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryClearingAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.twilightAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryClearingAccountRequest {
    return { twilightAddress: isSet(object.twilightAddress) ? globalThis.String(object.twilightAddress) : "" };
  },

  toJSON(message: QueryClearingAccountRequest): unknown {
    const obj: any = {};
    if (message.twilightAddress !== "") {
      obj.twilightAddress = message.twilightAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryClearingAccountRequest>, I>>(base?: I): QueryClearingAccountRequest {
    return QueryClearingAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryClearingAccountRequest>, I>>(object: I): QueryClearingAccountRequest {
    const message = createBaseQueryClearingAccountRequest();
    message.twilightAddress = object.twilightAddress ?? "";
    return message;
  },
};

function createBaseQueryClearingAccountResponse(): QueryClearingAccountResponse {
  return { ClearingAccount: undefined };
}

export const QueryClearingAccountResponse = {
  encode(message: QueryClearingAccountResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ClearingAccount !== undefined) {
      ClearingAccount.encode(message.ClearingAccount, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryClearingAccountResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryClearingAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ClearingAccount = ClearingAccount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryClearingAccountResponse {
    return {
      ClearingAccount: isSet(object.ClearingAccount) ? ClearingAccount.fromJSON(object.ClearingAccount) : undefined,
    };
  },

  toJSON(message: QueryClearingAccountResponse): unknown {
    const obj: any = {};
    if (message.ClearingAccount !== undefined) {
      obj.ClearingAccount = ClearingAccount.toJSON(message.ClearingAccount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryClearingAccountResponse>, I>>(base?: I): QueryClearingAccountResponse {
    return QueryClearingAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryClearingAccountResponse>, I>>(object: I): QueryClearingAccountResponse {
    const message = createBaseQueryClearingAccountResponse();
    message.ClearingAccount = (object.ClearingAccount !== undefined && object.ClearingAccount !== null)
      ? ClearingAccount.fromPartial(object.ClearingAccount)
      : undefined;
    return message;
  },
};

function createBaseQueryReserveClearingAccountsAllRequest(): QueryReserveClearingAccountsAllRequest {
  return { reserveId: "0" };
}

export const QueryReserveClearingAccountsAllRequest = {
  encode(message: QueryReserveClearingAccountsAllRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryReserveClearingAccountsAllRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReserveClearingAccountsAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReserveClearingAccountsAllRequest {
    return { reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0" };
  },

  toJSON(message: QueryReserveClearingAccountsAllRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReserveClearingAccountsAllRequest>, I>>(
    base?: I,
  ): QueryReserveClearingAccountsAllRequest {
    return QueryReserveClearingAccountsAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReserveClearingAccountsAllRequest>, I>>(
    object: I,
  ): QueryReserveClearingAccountsAllRequest {
    const message = createBaseQueryReserveClearingAccountsAllRequest();
    message.reserveId = object.reserveId ?? "0";
    return message;
  },
};

function createBaseQueryReserveClearingAccountsAllResponse(): QueryReserveClearingAccountsAllResponse {
  return { ReserveClearingAccountsAll: [] };
}

export const QueryReserveClearingAccountsAllResponse = {
  encode(message: QueryReserveClearingAccountsAllResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ReserveClearingAccountsAll) {
      ClearingAccount.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryReserveClearingAccountsAllResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReserveClearingAccountsAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ReserveClearingAccountsAll.push(ClearingAccount.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReserveClearingAccountsAllResponse {
    return {
      ReserveClearingAccountsAll: globalThis.Array.isArray(object?.ReserveClearingAccountsAll)
        ? object.ReserveClearingAccountsAll.map((e: any) => ClearingAccount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryReserveClearingAccountsAllResponse): unknown {
    const obj: any = {};
    if (message.ReserveClearingAccountsAll?.length) {
      obj.ReserveClearingAccountsAll = message.ReserveClearingAccountsAll.map((e) => ClearingAccount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReserveClearingAccountsAllResponse>, I>>(
    base?: I,
  ): QueryReserveClearingAccountsAllResponse {
    return QueryReserveClearingAccountsAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReserveClearingAccountsAllResponse>, I>>(
    object: I,
  ): QueryReserveClearingAccountsAllResponse {
    const message = createBaseQueryReserveClearingAccountsAllResponse();
    message.ReserveClearingAccountsAll =
      object.ReserveClearingAccountsAll?.map((e) => ClearingAccount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryReserveWithdrawSnapshotRequest(): QueryReserveWithdrawSnapshotRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QueryReserveWithdrawSnapshotRequest = {
  encode(message: QueryReserveWithdrawSnapshotRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryReserveWithdrawSnapshotRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReserveWithdrawSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReserveWithdrawSnapshotRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QueryReserveWithdrawSnapshotRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReserveWithdrawSnapshotRequest>, I>>(
    base?: I,
  ): QueryReserveWithdrawSnapshotRequest {
    return QueryReserveWithdrawSnapshotRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReserveWithdrawSnapshotRequest>, I>>(
    object: I,
  ): QueryReserveWithdrawSnapshotRequest {
    const message = createBaseQueryReserveWithdrawSnapshotRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQueryReserveWithdrawSnapshotResponse(): QueryReserveWithdrawSnapshotResponse {
  return { ReserveWithdrawSnapshot: undefined };
}

export const QueryReserveWithdrawSnapshotResponse = {
  encode(message: QueryReserveWithdrawSnapshotResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ReserveWithdrawSnapshot !== undefined) {
      ReserveWithdrawSnapshot.encode(message.ReserveWithdrawSnapshot, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryReserveWithdrawSnapshotResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReserveWithdrawSnapshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ReserveWithdrawSnapshot = ReserveWithdrawSnapshot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReserveWithdrawSnapshotResponse {
    return {
      ReserveWithdrawSnapshot: isSet(object.ReserveWithdrawSnapshot)
        ? ReserveWithdrawSnapshot.fromJSON(object.ReserveWithdrawSnapshot)
        : undefined,
    };
  },

  toJSON(message: QueryReserveWithdrawSnapshotResponse): unknown {
    const obj: any = {};
    if (message.ReserveWithdrawSnapshot !== undefined) {
      obj.ReserveWithdrawSnapshot = ReserveWithdrawSnapshot.toJSON(message.ReserveWithdrawSnapshot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReserveWithdrawSnapshotResponse>, I>>(
    base?: I,
  ): QueryReserveWithdrawSnapshotResponse {
    return QueryReserveWithdrawSnapshotResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReserveWithdrawSnapshotResponse>, I>>(
    object: I,
  ): QueryReserveWithdrawSnapshotResponse {
    const message = createBaseQueryReserveWithdrawSnapshotResponse();
    message.ReserveWithdrawSnapshot =
      (object.ReserveWithdrawSnapshot !== undefined && object.ReserveWithdrawSnapshot !== null)
        ? ReserveWithdrawSnapshot.fromPartial(object.ReserveWithdrawSnapshot)
        : undefined;
    return message;
  },
};

function createBaseQueryRefundTxSnapshotRequest(): QueryRefundTxSnapshotRequest {
  return { reserveId: "0", roundId: "0" };
}

export const QueryRefundTxSnapshotRequest = {
  encode(message: QueryRefundTxSnapshotRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    if (message.roundId !== "0") {
      writer.uint32(16).uint64(message.roundId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRefundTxSnapshotRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRefundTxSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.roundId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRefundTxSnapshotRequest {
    return {
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      roundId: isSet(object.roundId) ? globalThis.String(object.roundId) : "0",
    };
  },

  toJSON(message: QueryRefundTxSnapshotRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.roundId !== "0") {
      obj.roundId = message.roundId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRefundTxSnapshotRequest>, I>>(base?: I): QueryRefundTxSnapshotRequest {
    return QueryRefundTxSnapshotRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRefundTxSnapshotRequest>, I>>(object: I): QueryRefundTxSnapshotRequest {
    const message = createBaseQueryRefundTxSnapshotRequest();
    message.reserveId = object.reserveId ?? "0";
    message.roundId = object.roundId ?? "0";
    return message;
  },
};

function createBaseQueryRefundTxSnapshotResponse(): QueryRefundTxSnapshotResponse {
  return { RefundTxSnapshot: undefined };
}

export const QueryRefundTxSnapshotResponse = {
  encode(message: QueryRefundTxSnapshotResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.RefundTxSnapshot !== undefined) {
      RefundTxSnapshot.encode(message.RefundTxSnapshot, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryRefundTxSnapshotResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRefundTxSnapshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.RefundTxSnapshot = RefundTxSnapshot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRefundTxSnapshotResponse {
    return {
      RefundTxSnapshot: isSet(object.RefundTxSnapshot) ? RefundTxSnapshot.fromJSON(object.RefundTxSnapshot) : undefined,
    };
  },

  toJSON(message: QueryRefundTxSnapshotResponse): unknown {
    const obj: any = {};
    if (message.RefundTxSnapshot !== undefined) {
      obj.RefundTxSnapshot = RefundTxSnapshot.toJSON(message.RefundTxSnapshot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRefundTxSnapshotResponse>, I>>(base?: I): QueryRefundTxSnapshotResponse {
    return QueryRefundTxSnapshotResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRefundTxSnapshotResponse>, I>>(
    object: I,
  ): QueryRefundTxSnapshotResponse {
    const message = createBaseQueryRefundTxSnapshotResponse();
    message.RefundTxSnapshot = (object.RefundTxSnapshot !== undefined && object.RefundTxSnapshot !== null)
      ? RefundTxSnapshot.fromPartial(object.RefundTxSnapshot)
      : undefined;
    return message;
  },
};

function createBaseQueryBtcWithdrawRequestRequest(): QueryBtcWithdrawRequestRequest {
  return { twilightAddress: "", reserveId: "0", btcAddress: "", withdrawAmount: "0" };
}

export const QueryBtcWithdrawRequestRequest = {
  encode(message: QueryBtcWithdrawRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.twilightAddress !== "") {
      writer.uint32(10).string(message.twilightAddress);
    }
    if (message.reserveId !== "0") {
      writer.uint32(16).uint64(message.reserveId);
    }
    if (message.btcAddress !== "") {
      writer.uint32(26).string(message.btcAddress);
    }
    if (message.withdrawAmount !== "0") {
      writer.uint32(32).uint64(message.withdrawAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBtcWithdrawRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBtcWithdrawRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.twilightAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.btcAddress = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.withdrawAmount = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBtcWithdrawRequestRequest {
    return {
      twilightAddress: isSet(object.twilightAddress) ? globalThis.String(object.twilightAddress) : "",
      reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0",
      btcAddress: isSet(object.btcAddress) ? globalThis.String(object.btcAddress) : "",
      withdrawAmount: isSet(object.withdrawAmount) ? globalThis.String(object.withdrawAmount) : "0",
    };
  },

  toJSON(message: QueryBtcWithdrawRequestRequest): unknown {
    const obj: any = {};
    if (message.twilightAddress !== "") {
      obj.twilightAddress = message.twilightAddress;
    }
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    if (message.btcAddress !== "") {
      obj.btcAddress = message.btcAddress;
    }
    if (message.withdrawAmount !== "0") {
      obj.withdrawAmount = message.withdrawAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBtcWithdrawRequestRequest>, I>>(base?: I): QueryBtcWithdrawRequestRequest {
    return QueryBtcWithdrawRequestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBtcWithdrawRequestRequest>, I>>(
    object: I,
  ): QueryBtcWithdrawRequestRequest {
    const message = createBaseQueryBtcWithdrawRequestRequest();
    message.twilightAddress = object.twilightAddress ?? "";
    message.reserveId = object.reserveId ?? "0";
    message.btcAddress = object.btcAddress ?? "";
    message.withdrawAmount = object.withdrawAmount ?? "0";
    return message;
  },
};

function createBaseQueryBtcWithdrawRequestResponse(): QueryBtcWithdrawRequestResponse {
  return { BtcWithdrawRequest: undefined };
}

export const QueryBtcWithdrawRequestResponse = {
  encode(message: QueryBtcWithdrawRequestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.BtcWithdrawRequest !== undefined) {
      BtcWithdrawRequestInternal.encode(message.BtcWithdrawRequest, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryBtcWithdrawRequestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBtcWithdrawRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.BtcWithdrawRequest = BtcWithdrawRequestInternal.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBtcWithdrawRequestResponse {
    return {
      BtcWithdrawRequest: isSet(object.BtcWithdrawRequest)
        ? BtcWithdrawRequestInternal.fromJSON(object.BtcWithdrawRequest)
        : undefined,
    };
  },

  toJSON(message: QueryBtcWithdrawRequestResponse): unknown {
    const obj: any = {};
    if (message.BtcWithdrawRequest !== undefined) {
      obj.BtcWithdrawRequest = BtcWithdrawRequestInternal.toJSON(message.BtcWithdrawRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBtcWithdrawRequestResponse>, I>>(base?: I): QueryBtcWithdrawRequestResponse {
    return QueryBtcWithdrawRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBtcWithdrawRequestResponse>, I>>(
    object: I,
  ): QueryBtcWithdrawRequestResponse {
    const message = createBaseQueryBtcWithdrawRequestResponse();
    message.BtcWithdrawRequest = (object.BtcWithdrawRequest !== undefined && object.BtcWithdrawRequest !== null)
      ? BtcWithdrawRequestInternal.fromPartial(object.BtcWithdrawRequest)
      : undefined;
    return message;
  },
};

function createBaseQueryReserveWithdrawPoolRequest(): QueryReserveWithdrawPoolRequest {
  return { reserveId: "0" };
}

export const QueryReserveWithdrawPoolRequest = {
  encode(message: QueryReserveWithdrawPoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reserveId !== "0") {
      writer.uint32(8).uint64(message.reserveId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryReserveWithdrawPoolRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReserveWithdrawPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reserveId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReserveWithdrawPoolRequest {
    return { reserveId: isSet(object.reserveId) ? globalThis.String(object.reserveId) : "0" };
  },

  toJSON(message: QueryReserveWithdrawPoolRequest): unknown {
    const obj: any = {};
    if (message.reserveId !== "0") {
      obj.reserveId = message.reserveId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReserveWithdrawPoolRequest>, I>>(base?: I): QueryReserveWithdrawPoolRequest {
    return QueryReserveWithdrawPoolRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReserveWithdrawPoolRequest>, I>>(
    object: I,
  ): QueryReserveWithdrawPoolRequest {
    const message = createBaseQueryReserveWithdrawPoolRequest();
    message.reserveId = object.reserveId ?? "0";
    return message;
  },
};

function createBaseQueryReserveWithdrawPoolResponse(): QueryReserveWithdrawPoolResponse {
  return { ReserveWithdrawPool: undefined };
}

export const QueryReserveWithdrawPoolResponse = {
  encode(message: QueryReserveWithdrawPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ReserveWithdrawPool !== undefined) {
      ReserveWithdrawPool.encode(message.ReserveWithdrawPool, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryReserveWithdrawPoolResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReserveWithdrawPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ReserveWithdrawPool = ReserveWithdrawPool.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReserveWithdrawPoolResponse {
    return {
      ReserveWithdrawPool: isSet(object.ReserveWithdrawPool)
        ? ReserveWithdrawPool.fromJSON(object.ReserveWithdrawPool)
        : undefined,
    };
  },

  toJSON(message: QueryReserveWithdrawPoolResponse): unknown {
    const obj: any = {};
    if (message.ReserveWithdrawPool !== undefined) {
      obj.ReserveWithdrawPool = ReserveWithdrawPool.toJSON(message.ReserveWithdrawPool);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryReserveWithdrawPoolResponse>, I>>(
    base?: I,
  ): QueryReserveWithdrawPoolResponse {
    return QueryReserveWithdrawPoolResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryReserveWithdrawPoolResponse>, I>>(
    object: I,
  ): QueryReserveWithdrawPoolResponse {
    const message = createBaseQueryReserveWithdrawPoolResponse();
    message.ReserveWithdrawPool = (object.ReserveWithdrawPool !== undefined && object.ReserveWithdrawPool !== null)
      ? ReserveWithdrawPool.fromPartial(object.ReserveWithdrawPool)
      : undefined;
    return message;
  },
};

function createBaseQueryFragmentByIdRequest(): QueryFragmentByIdRequest {
  return { fragmentId: "0" };
}

export const QueryFragmentByIdRequest = {
  encode(message: QueryFragmentByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fragmentId !== "0") {
      writer.uint32(8).uint64(message.fragmentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryFragmentByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFragmentByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fragmentId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryFragmentByIdRequest {
    return { fragmentId: isSet(object.fragmentId) ? globalThis.String(object.fragmentId) : "0" };
  },

  toJSON(message: QueryFragmentByIdRequest): unknown {
    const obj: any = {};
    if (message.fragmentId !== "0") {
      obj.fragmentId = message.fragmentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryFragmentByIdRequest>, I>>(base?: I): QueryFragmentByIdRequest {
    return QueryFragmentByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryFragmentByIdRequest>, I>>(object: I): QueryFragmentByIdRequest {
    const message = createBaseQueryFragmentByIdRequest();
    message.fragmentId = object.fragmentId ?? "0";
    return message;
  },
};

function createBaseQueryFragmentByIdResponse(): QueryFragmentByIdResponse {
  return { Fragment: undefined };
}

export const QueryFragmentByIdResponse = {
  encode(message: QueryFragmentByIdResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Fragment !== undefined) {
      Fragment.encode(message.Fragment, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryFragmentByIdResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryFragmentByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Fragment = Fragment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryFragmentByIdResponse {
    return { Fragment: isSet(object.Fragment) ? Fragment.fromJSON(object.Fragment) : undefined };
  },

  toJSON(message: QueryFragmentByIdResponse): unknown {
    const obj: any = {};
    if (message.Fragment !== undefined) {
      obj.Fragment = Fragment.toJSON(message.Fragment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryFragmentByIdResponse>, I>>(base?: I): QueryFragmentByIdResponse {
    return QueryFragmentByIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryFragmentByIdResponse>, I>>(object: I): QueryFragmentByIdResponse {
    const message = createBaseQueryFragmentByIdResponse();
    message.Fragment = (object.Fragment !== undefined && object.Fragment !== null)
      ? Fragment.fromPartial(object.Fragment)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllFragmentsRequest(): QueryGetAllFragmentsRequest {
  return {};
}

export const QueryGetAllFragmentsRequest = {
  encode(_: QueryGetAllFragmentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetAllFragmentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllFragmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryGetAllFragmentsRequest {
    return {};
  },

  toJSON(_: QueryGetAllFragmentsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllFragmentsRequest>, I>>(base?: I): QueryGetAllFragmentsRequest {
    return QueryGetAllFragmentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllFragmentsRequest>, I>>(_: I): QueryGetAllFragmentsRequest {
    const message = createBaseQueryGetAllFragmentsRequest();
    return message;
  },
};

function createBaseQueryGetAllFragmentsResponse(): QueryGetAllFragmentsResponse {
  return { Fragments: [] };
}

export const QueryGetAllFragmentsResponse = {
  encode(message: QueryGetAllFragmentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Fragments) {
      Fragment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetAllFragmentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllFragmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Fragments.push(Fragment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllFragmentsResponse {
    return {
      Fragments: globalThis.Array.isArray(object?.Fragments)
        ? object.Fragments.map((e: any) => Fragment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryGetAllFragmentsResponse): unknown {
    const obj: any = {};
    if (message.Fragments?.length) {
      obj.Fragments = message.Fragments.map((e) => Fragment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllFragmentsResponse>, I>>(base?: I): QueryGetAllFragmentsResponse {
    return QueryGetAllFragmentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllFragmentsResponse>, I>>(object: I): QueryGetAllFragmentsResponse {
    const message = createBaseQueryGetAllFragmentsResponse();
    message.Fragments = object.Fragments?.map((e) => Fragment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQuerySignerApplicationsRequest(): QuerySignerApplicationsRequest {
  return { fragmentId: "0" };
}

export const QuerySignerApplicationsRequest = {
  encode(message: QuerySignerApplicationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fragmentId !== "0") {
      writer.uint32(8).uint64(message.fragmentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignerApplicationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignerApplicationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fragmentId = longToString(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignerApplicationsRequest {
    return { fragmentId: isSet(object.fragmentId) ? globalThis.String(object.fragmentId) : "0" };
  },

  toJSON(message: QuerySignerApplicationsRequest): unknown {
    const obj: any = {};
    if (message.fragmentId !== "0") {
      obj.fragmentId = message.fragmentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignerApplicationsRequest>, I>>(base?: I): QuerySignerApplicationsRequest {
    return QuerySignerApplicationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignerApplicationsRequest>, I>>(
    object: I,
  ): QuerySignerApplicationsRequest {
    const message = createBaseQuerySignerApplicationsRequest();
    message.fragmentId = object.fragmentId ?? "0";
    return message;
  },
};

function createBaseQuerySignerApplicationsResponse(): QuerySignerApplicationsResponse {
  return { SignerApplications: [] };
}

export const QuerySignerApplicationsResponse = {
  encode(message: QuerySignerApplicationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.SignerApplications) {
      SignerApplication.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuerySignerApplicationsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignerApplicationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.SignerApplications.push(SignerApplication.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignerApplicationsResponse {
    return {
      SignerApplications: globalThis.Array.isArray(object?.SignerApplications)
        ? object.SignerApplications.map((e: any) => SignerApplication.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuerySignerApplicationsResponse): unknown {
    const obj: any = {};
    if (message.SignerApplications?.length) {
      obj.SignerApplications = message.SignerApplications.map((e) => SignerApplication.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignerApplicationsResponse>, I>>(base?: I): QuerySignerApplicationsResponse {
    return QuerySignerApplicationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignerApplicationsResponse>, I>>(
    object: I,
  ): QuerySignerApplicationsResponse {
    const message = createBaseQuerySignerApplicationsResponse();
    message.SignerApplications = object.SignerApplications?.map((e) => SignerApplication.fromPartial(e)) || [];
    return message;
  },
};

/** Query defines the gRPC querier service. */
export type QueryService = typeof QueryService;
export const QueryService = {
  /** Parameters queries the parameters of the module. */
  params: {
    path: "/twilightproject.nyks.volt.Query/Params",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryParamsRequest) => Buffer.from(QueryParamsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryParamsRequest.decode(value),
    responseSerialize: (value: QueryParamsResponse) => Buffer.from(QueryParamsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryParamsResponse.decode(value),
  },
  /** Queries a list of BtcReserve items. */
  btcReserve: {
    path: "/twilightproject.nyks.volt.Query/BtcReserve",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryBtcReserveRequest) => Buffer.from(QueryBtcReserveRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryBtcReserveRequest.decode(value),
    responseSerialize: (value: QueryBtcReserveResponse) => Buffer.from(QueryBtcReserveResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryBtcReserveResponse.decode(value),
  },
  /** Queries a list of ClearingAccount items. */
  clearingAccount: {
    path: "/twilightproject.nyks.volt.Query/ClearingAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryClearingAccountRequest) =>
      Buffer.from(QueryClearingAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryClearingAccountRequest.decode(value),
    responseSerialize: (value: QueryClearingAccountResponse) =>
      Buffer.from(QueryClearingAccountResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryClearingAccountResponse.decode(value),
  },
  /** Queries a list of ReserveClearingAccountsAll items. */
  reserveClearingAccountsAll: {
    path: "/twilightproject.nyks.volt.Query/ReserveClearingAccountsAll",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryReserveClearingAccountsAllRequest) =>
      Buffer.from(QueryReserveClearingAccountsAllRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryReserveClearingAccountsAllRequest.decode(value),
    responseSerialize: (value: QueryReserveClearingAccountsAllResponse) =>
      Buffer.from(QueryReserveClearingAccountsAllResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryReserveClearingAccountsAllResponse.decode(value),
  },
  /** Queries a list of ReserveWithdrawSnapshot items. */
  reserveWithdrawSnapshot: {
    path: "/twilightproject.nyks.volt.Query/ReserveWithdrawSnapshot",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryReserveWithdrawSnapshotRequest) =>
      Buffer.from(QueryReserveWithdrawSnapshotRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryReserveWithdrawSnapshotRequest.decode(value),
    responseSerialize: (value: QueryReserveWithdrawSnapshotResponse) =>
      Buffer.from(QueryReserveWithdrawSnapshotResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryReserveWithdrawSnapshotResponse.decode(value),
  },
  /** Queries a list of RefundTxSnapshot items. */
  refundTxSnapshot: {
    path: "/twilightproject.nyks.volt.Query/RefundTxSnapshot",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryRefundTxSnapshotRequest) =>
      Buffer.from(QueryRefundTxSnapshotRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryRefundTxSnapshotRequest.decode(value),
    responseSerialize: (value: QueryRefundTxSnapshotResponse) =>
      Buffer.from(QueryRefundTxSnapshotResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryRefundTxSnapshotResponse.decode(value),
  },
  /** Queries a list of BtcWithdrawRequest items. */
  btcWithdrawRequest: {
    path: "/twilightproject.nyks.volt.Query/BtcWithdrawRequest",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryBtcWithdrawRequestRequest) =>
      Buffer.from(QueryBtcWithdrawRequestRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryBtcWithdrawRequestRequest.decode(value),
    responseSerialize: (value: QueryBtcWithdrawRequestResponse) =>
      Buffer.from(QueryBtcWithdrawRequestResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryBtcWithdrawRequestResponse.decode(value),
  },
  /** Queries a list of ReserveWithdrawPool items. */
  reserveWithdrawPool: {
    path: "/twilightproject.nyks.volt.Query/ReserveWithdrawPool",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryReserveWithdrawPoolRequest) =>
      Buffer.from(QueryReserveWithdrawPoolRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryReserveWithdrawPoolRequest.decode(value),
    responseSerialize: (value: QueryReserveWithdrawPoolResponse) =>
      Buffer.from(QueryReserveWithdrawPoolResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryReserveWithdrawPoolResponse.decode(value),
  },
  /** Queries a list of FragmentById items. */
  fragmentById: {
    path: "/twilightproject.nyks.volt.Query/FragmentById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryFragmentByIdRequest) => Buffer.from(QueryFragmentByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryFragmentByIdRequest.decode(value),
    responseSerialize: (value: QueryFragmentByIdResponse) =>
      Buffer.from(QueryFragmentByIdResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryFragmentByIdResponse.decode(value),
  },
  /** Queries a list of GetAllFragments items. */
  getAllFragments: {
    path: "/twilightproject.nyks.volt.Query/GetAllFragments",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QueryGetAllFragmentsRequest) =>
      Buffer.from(QueryGetAllFragmentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QueryGetAllFragmentsRequest.decode(value),
    responseSerialize: (value: QueryGetAllFragmentsResponse) =>
      Buffer.from(QueryGetAllFragmentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QueryGetAllFragmentsResponse.decode(value),
  },
  /** Queries a list of SignerApplications items. */
  signerApplications: {
    path: "/twilightproject.nyks.volt.Query/SignerApplications",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QuerySignerApplicationsRequest) =>
      Buffer.from(QuerySignerApplicationsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => QuerySignerApplicationsRequest.decode(value),
    responseSerialize: (value: QuerySignerApplicationsResponse) =>
      Buffer.from(QuerySignerApplicationsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => QuerySignerApplicationsResponse.decode(value),
  },
} as const;

export interface QueryServer extends UntypedServiceImplementation {
  /** Parameters queries the parameters of the module. */
  params: handleUnaryCall<QueryParamsRequest, QueryParamsResponse>;
  /** Queries a list of BtcReserve items. */
  btcReserve: handleUnaryCall<QueryBtcReserveRequest, QueryBtcReserveResponse>;
  /** Queries a list of ClearingAccount items. */
  clearingAccount: handleUnaryCall<QueryClearingAccountRequest, QueryClearingAccountResponse>;
  /** Queries a list of ReserveClearingAccountsAll items. */
  reserveClearingAccountsAll: handleUnaryCall<
    QueryReserveClearingAccountsAllRequest,
    QueryReserveClearingAccountsAllResponse
  >;
  /** Queries a list of ReserveWithdrawSnapshot items. */
  reserveWithdrawSnapshot: handleUnaryCall<QueryReserveWithdrawSnapshotRequest, QueryReserveWithdrawSnapshotResponse>;
  /** Queries a list of RefundTxSnapshot items. */
  refundTxSnapshot: handleUnaryCall<QueryRefundTxSnapshotRequest, QueryRefundTxSnapshotResponse>;
  /** Queries a list of BtcWithdrawRequest items. */
  btcWithdrawRequest: handleUnaryCall<QueryBtcWithdrawRequestRequest, QueryBtcWithdrawRequestResponse>;
  /** Queries a list of ReserveWithdrawPool items. */
  reserveWithdrawPool: handleUnaryCall<QueryReserveWithdrawPoolRequest, QueryReserveWithdrawPoolResponse>;
  /** Queries a list of FragmentById items. */
  fragmentById: handleUnaryCall<QueryFragmentByIdRequest, QueryFragmentByIdResponse>;
  /** Queries a list of GetAllFragments items. */
  getAllFragments: handleUnaryCall<QueryGetAllFragmentsRequest, QueryGetAllFragmentsResponse>;
  /** Queries a list of SignerApplications items. */
  signerApplications: handleUnaryCall<QuerySignerApplicationsRequest, QuerySignerApplicationsResponse>;
}

export interface QueryClient extends Client {
  /** Parameters queries the parameters of the module. */
  params(
    request: QueryParamsRequest,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  params(
    request: QueryParamsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  params(
    request: QueryParamsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryParamsResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of BtcReserve items. */
  btcReserve(
    request: QueryBtcReserveRequest,
    callback: (error: ServiceError | null, response: QueryBtcReserveResponse) => void,
  ): ClientUnaryCall;
  btcReserve(
    request: QueryBtcReserveRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryBtcReserveResponse) => void,
  ): ClientUnaryCall;
  btcReserve(
    request: QueryBtcReserveRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryBtcReserveResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of ClearingAccount items. */
  clearingAccount(
    request: QueryClearingAccountRequest,
    callback: (error: ServiceError | null, response: QueryClearingAccountResponse) => void,
  ): ClientUnaryCall;
  clearingAccount(
    request: QueryClearingAccountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryClearingAccountResponse) => void,
  ): ClientUnaryCall;
  clearingAccount(
    request: QueryClearingAccountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryClearingAccountResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of ReserveClearingAccountsAll items. */
  reserveClearingAccountsAll(
    request: QueryReserveClearingAccountsAllRequest,
    callback: (error: ServiceError | null, response: QueryReserveClearingAccountsAllResponse) => void,
  ): ClientUnaryCall;
  reserveClearingAccountsAll(
    request: QueryReserveClearingAccountsAllRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryReserveClearingAccountsAllResponse) => void,
  ): ClientUnaryCall;
  reserveClearingAccountsAll(
    request: QueryReserveClearingAccountsAllRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryReserveClearingAccountsAllResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of ReserveWithdrawSnapshot items. */
  reserveWithdrawSnapshot(
    request: QueryReserveWithdrawSnapshotRequest,
    callback: (error: ServiceError | null, response: QueryReserveWithdrawSnapshotResponse) => void,
  ): ClientUnaryCall;
  reserveWithdrawSnapshot(
    request: QueryReserveWithdrawSnapshotRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryReserveWithdrawSnapshotResponse) => void,
  ): ClientUnaryCall;
  reserveWithdrawSnapshot(
    request: QueryReserveWithdrawSnapshotRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryReserveWithdrawSnapshotResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of RefundTxSnapshot items. */
  refundTxSnapshot(
    request: QueryRefundTxSnapshotRequest,
    callback: (error: ServiceError | null, response: QueryRefundTxSnapshotResponse) => void,
  ): ClientUnaryCall;
  refundTxSnapshot(
    request: QueryRefundTxSnapshotRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryRefundTxSnapshotResponse) => void,
  ): ClientUnaryCall;
  refundTxSnapshot(
    request: QueryRefundTxSnapshotRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryRefundTxSnapshotResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of BtcWithdrawRequest items. */
  btcWithdrawRequest(
    request: QueryBtcWithdrawRequestRequest,
    callback: (error: ServiceError | null, response: QueryBtcWithdrawRequestResponse) => void,
  ): ClientUnaryCall;
  btcWithdrawRequest(
    request: QueryBtcWithdrawRequestRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryBtcWithdrawRequestResponse) => void,
  ): ClientUnaryCall;
  btcWithdrawRequest(
    request: QueryBtcWithdrawRequestRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryBtcWithdrawRequestResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of ReserveWithdrawPool items. */
  reserveWithdrawPool(
    request: QueryReserveWithdrawPoolRequest,
    callback: (error: ServiceError | null, response: QueryReserveWithdrawPoolResponse) => void,
  ): ClientUnaryCall;
  reserveWithdrawPool(
    request: QueryReserveWithdrawPoolRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryReserveWithdrawPoolResponse) => void,
  ): ClientUnaryCall;
  reserveWithdrawPool(
    request: QueryReserveWithdrawPoolRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryReserveWithdrawPoolResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of FragmentById items. */
  fragmentById(
    request: QueryFragmentByIdRequest,
    callback: (error: ServiceError | null, response: QueryFragmentByIdResponse) => void,
  ): ClientUnaryCall;
  fragmentById(
    request: QueryFragmentByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryFragmentByIdResponse) => void,
  ): ClientUnaryCall;
  fragmentById(
    request: QueryFragmentByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryFragmentByIdResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of GetAllFragments items. */
  getAllFragments(
    request: QueryGetAllFragmentsRequest,
    callback: (error: ServiceError | null, response: QueryGetAllFragmentsResponse) => void,
  ): ClientUnaryCall;
  getAllFragments(
    request: QueryGetAllFragmentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QueryGetAllFragmentsResponse) => void,
  ): ClientUnaryCall;
  getAllFragments(
    request: QueryGetAllFragmentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QueryGetAllFragmentsResponse) => void,
  ): ClientUnaryCall;
  /** Queries a list of SignerApplications items. */
  signerApplications(
    request: QuerySignerApplicationsRequest,
    callback: (error: ServiceError | null, response: QuerySignerApplicationsResponse) => void,
  ): ClientUnaryCall;
  signerApplications(
    request: QuerySignerApplicationsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QuerySignerApplicationsResponse) => void,
  ): ClientUnaryCall;
  signerApplications(
    request: QuerySignerApplicationsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QuerySignerApplicationsResponse) => void,
  ): ClientUnaryCall;
}

export const QueryClient = makeGenericClientConstructor(QueryService, "twilightproject.nyks.volt.Query") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): QueryClient;
  service: typeof QueryService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToString(long: Long) {
  return long.toString();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
